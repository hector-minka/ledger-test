"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.bufferConcat = bufferConcat;
exports.parseB64Object = parseB64Object;
exports.signJWT = signJWT;
exports.getJWTProtectedHeader = getJWTProtectedHeader;
exports.verifyJWT = verifyJWT;
const crypto_1 = __importDefault(require("crypto"));
const ed25519 = __importStar(require("@noble/ed25519"));
const jose_1 = require("jose");
const moment_1 = __importDefault(require("moment"));
const jwtVerificationMethods = {
    ['EdDSA']: verifyEdDSAJWT,
    ['RS256']: verifyRS256JWT,
};
/**
 * Webcrypto instance. Either in browser `global?.crypto`
 * or in node for testing purposes `crypto?.webcrypto`
 */
const webcrypto = global?.crypto ?? crypto_1.default?.webcrypto;
function assertWebcryptoSupport() {
    if (!webcrypto) {
        throw new Error('Unable to perform operation, `webcrypto` is not defined');
    }
    if (!webcrypto.subtle) {
        throw new Error('Unable to perform operation, `webcrypto.subtle` is not defined');
    }
}
/**
 * This function is used to concatenate multiple buffers
 * into a single buffer.
 * It's used further in the code to concatenate the header
 * and payload with a dot separator.
 */
function bufferConcat(...buffers) {
    const size = buffers.reduce((acc, { length }) => acc + length, 0);
    const buf = new Uint8Array(size);
    let i = 0;
    buffers.forEach((buffer) => {
        buf.set(buffer, i);
        i += buffer.length;
    });
    return buf;
}
/**
 * This function abstracts the decoding of a base64 encoded
 * JSON into an object.
 */
function parseB64Object(b64) {
    const decoder = new TextDecoder();
    const decoded = jose_1.base64url.decode(b64);
    return JSON.parse(decoder.decode(decoded));
}
async function signJWT(payload, secret, kid) {
    const encoder = new TextEncoder();
    // Convert both the payload and header to buffers
    let payloadBuffer = encoder.encode(JSON.stringify(payload));
    payloadBuffer = encoder.encode(jose_1.base64url.encode(payloadBuffer));
    const header = { alg: 'EdDSA', kid };
    const headerBuffer = encoder.encode(jose_1.base64url.encode(JSON.stringify(header)));
    /**
     * Concatenate both header and payload with a dot separator
     * and get the hash of the result in hex format.
     */
    const data = bufferConcat(headerBuffer, encoder.encode('.'), payloadBuffer);
    const dataHash = Buffer.from(data).toString('hex');
    /**
     * Sign the hash with the secret key using the
     * noble/ed25519 library.
     */
    const privateKey = Buffer.from(secret, 'base64');
    try {
        const signature = await ed25519.sign(dataHash, privateKey);
        const encodedSignature = jose_1.base64url.encode(signature);
        return `${jose_1.base64url.encode(JSON.stringify(header))}.${jose_1.base64url.encode(JSON.stringify(payload))}.${encodedSignature}`;
    }
    catch (error) {
        // If the error is about the private key length, throw an specific error
        if (error.message === 'Expected 32 bytes') {
            const publicLength = Buffer.from(secret, 'base64').toString('hex').length;
            throw new Error(`Unexpected raw private key length in hex ${publicLength}, expected 64`);
        }
        throw new Error('jwt signing failed');
    }
}
function getJWTProtectedHeader(jws) {
    // Get the parts from the JWS
    const { 0: protectedHeader } = jws.split('.');
    return JSON.parse(Buffer.from(protectedHeader, 'base64').toString());
}
async function verifyEdDSAJWT(jwt, publicKey) {
    const { 0: protectedHeader, 1: payload, 2: signature } = jwt.split('.');
    const encoder = new TextEncoder();
    // Use the header and payload to recreate the hash
    const data = bufferConcat(encoder.encode(protectedHeader), encoder.encode('.'), encoder.encode(payload));
    const dataHash = Buffer.from(data).toString('hex');
    /**
     * Verify the signature using the noble/ed25519 library.
     * The signature is base64 encoded, so we need to decode it
     * before verifying it.
     */
    let verified = false;
    try {
        verified = await ed25519.verify(Buffer.from(signature, 'base64'), dataHash, Buffer.from(publicKey, 'base64'));
    }
    catch (error) {
        // If the error is about the public key length, throw an specific error
        if (error.message === 'Expected 32 bytes') {
            const publicLength = Buffer.from(publicKey, 'base64').toString('hex').length;
            throw new Error(`Unexpected raw public key length in hex ${publicLength}, expected 64`);
        }
        verified = false;
    }
    /**
     * If the signature is invalid, throw an error from
     * the `jose` library.
     */
    if (!verified) {
        throw new Error('signature verification failed');
    }
    /**
     * Check the `exp` timestamp to see if the token is expired
     * or the expiration is invalid.
     */
    const decodedPayload = parseB64Object(payload);
    if (decodedPayload.iat >= decodedPayload.exp ||
        decodedPayload.exp < (0, moment_1.default)().valueOf() / 1000) {
        throw new Error('"exp" claim timestamp check failed');
    }
    /**
     * Return a decoded payload and header, as expected by
     * the type `JWTVerifyResult` of the `jose` library.
     */
    return {
        payload: parseB64Object(payload),
        protectedHeader: parseB64Object(protectedHeader),
    };
}
async function verifyRS256JWT(jwt, publicKey) {
    assertWebcryptoSupport();
    const keyHex = Buffer.from(publicKey, 'base64').toString('hex');
    const key = await webcrypto.subtle.importKey('spki', Buffer.from(keyHex, 'hex'), {
        name: 'RSASSA-PKCS1-v1_5',
        length: 2048,
        hash: {
            name: 'SHA-256',
        },
    }, false, ['verify']);
    return (0, jose_1.jwtVerify)(jwt, key, { algorithms: ['RS256'] });
}
function assertJWS(jws) {
    try {
        (0, jose_1.decodeJwt)(jws);
    }
    catch (err) {
        throw new Error(`Invalid Compact JWS`);
    }
}
async function verifyJWT(jws, publicKey, _format = 'ed25519-raw') {
    assertJWS(jws);
    const protectedHeaderData = (0, jose_1.decodeProtectedHeader)(jws);
    const { alg } = protectedHeaderData;
    if (!jwtVerificationMethods[alg]) {
        throw new Error('"alg" (Algorithm) Header Parameter not allowed');
    }
    return jwtVerificationMethods[alg](jws, publicKey);
}
//# sourceMappingURL=jwt.js.map