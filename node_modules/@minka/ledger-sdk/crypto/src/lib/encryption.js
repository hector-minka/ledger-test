"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.decryptAES = decryptAES;
exports.encryptAES = encryptAES;
exports.privateDecryptRsa = privateDecryptRsa;
exports.publicEncryptRsa = publicEncryptRsa;
const detect_node_1 = __importDefault(require("detect-node"));
const lodash_1 = __importDefault(require("lodash"));
const encryption_1 = require("./node/encryption");
/**
 * Encrypts a payload using the provided RSA public key.
 * @param payload String to encrypt
 * @param publicKey RSA public key
 * @returns Base64 encoded string representing encrypted payload
 */
async function publicEncryptRsa(payload, publicKey) {
    if (!detect_node_1.default) {
        throw new Error('publicEncrypt is only available in Node.js');
    }
    if (payload === undefined || payload === null) {
        throw new Error("Invalid value for 'payload'");
    }
    return (0, encryption_1.publicEncryptRsa)(payload, publicKey);
}
/**
 * Decrypts a payload using the provided RSA private key. Returns the decrypted payload as a UTF-8 string.
 * @param encryptedPayload Base64 encoded string representing encrypted payload
 * @param privateKey Private RSA key
 * @returns UTF-8 encoded string representing decrypted payload
 */
async function privateDecryptRsa(encryptedPayload, privateKey) {
    if (!detect_node_1.default) {
        throw new Error('privateDecrypt is only available in Node.js');
    }
    if (!encryptedPayload) {
        throw new Error("Invalid value for 'encryptedPayload'");
    }
    return (0, encryption_1.privateDecryptRsa)(encryptedPayload, privateKey);
}
/**
 * Encrypts a payload using the provided AES key and IV.
 * @param payload String to encrypt
 * @param aesKey Base64 encoded string or a Buffer, representing aes key
 * @param ivHex Optional. Hex encoded string representing IV. If not provided, a random IV will be generated.
 * It is recommended to always use a new IV for each encryption.
 * @returns Object containing the encrypted data, IV, and authentication tag.
 */
function encryptAES(payload, aesKey, ivHex = undefined) {
    if (!detect_node_1.default) {
        throw new Error('encryptAES is only available in Node.js');
    }
    if (payload === undefined || payload === null) {
        throw new Error("Invalid value for 'payload'");
    }
    return (0, encryption_1.encryptAES)(payload, aesKey, ivHex);
}
/**
 * Decrypts an AES encrypted payload using the provided key and IV.
 * @param encryptedPayload Encoded string representing encrypted payload
 * @param aesKey Base64 encoded string or a Buffer, representing aes key
 * @param ivHex Hex encoded string representing IV
 * @param authTag Hex encoded string representing authentication tag
 * @returns UTF-8 encoded string representing decrypted payload
 */
function decryptAES(encryptedPayload, aesKey, ivHex, authTag) {
    if (!detect_node_1.default) {
        throw new Error('decryptAES is only available in Node.js');
    }
    if (lodash_1.default.isNil(encryptedPayload)) {
        throw new Error("Invalid value for 'encryptedPayload'");
    }
    return (0, encryption_1.decryptAES)(encryptedPayload, aesKey, ivHex, authTag);
}
//# sourceMappingURL=encryption.js.map