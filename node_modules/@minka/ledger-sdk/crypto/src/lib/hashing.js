"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createHash = createHash;
exports.createSignatureDigest = createSignatureDigest;
const crypto_1 = __importDefault(require("crypto"));
const serialization_1 = require("./serialization");
const HASHING_ALGORITHM = 'sha256';
/**
 * Creates a hash of the provided data compatible
 * with the Minka Ledger. Returns the generated hash
 * as a hex encoded string.
 *
 * @param {any} data data that should be hashed
 * @returns {string} a hash of the provided data
 */
function createHash(data) {
    const serializedData = (0, serialization_1.serializeData)(data);
    return crypto_1.default
        .createHash(HASHING_ALGORITHM)
        .update(serializedData)
        .digest('hex');
}
/**
 * Creates a signature digest compatible with the ledger. This digest
 * is an input for signing. Signature digests allow us to attach additional
 * data when signing ledger records, this additional data is included in the
 * hash, which also means that it is protected by the signature.
 *
 * @param dataHash hash of the primary payload
 * @param signatureCustom additional data to attach with the signature
 * @returns a digest that should be used as signature input
 */
function createSignatureDigest(dataHash, signatureCustom) {
    const serializedCustomData = signatureCustom
        ? (0, serialization_1.serializeData)(signatureCustom)
        : '';
    return crypto_1.default
        .createHash(HASHING_ALGORITHM)
        .update(dataHash + serializedCustomData)
        .digest('hex');
}
//# sourceMappingURL=hashing.js.map