"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.decodeJWT = decodeJWT;
exports.signJWT = signJWT;
exports.getJWTProtectedHeader = getJWTProtectedHeader;
exports.verifyJWT = verifyJWT;
const detect_node_1 = __importDefault(require("detect-node"));
const jose_1 = require("jose");
const lodash_1 = __importDefault(require("lodash"));
const format_1 = require("../../../format/src");
const jwt_1 = require("./browser/jwt");
const jwt_2 = require("./node/jwt");
/**
 * Asserts Jwt payload is compatible with the ledger Jwt
 * standard payload.
 *
 * @param payload jwt standard payload
 * @returns parsed Ledger JWT Payload
 */
function assertLedgerJwtPayload(payload) {
    const { iss, sub, aud, jti, exp, iat, hsh } = payload;
    const errors = [];
    if (!iss || !lodash_1.default.isString(iss)) {
        errors.push('"iss" must be a string');
    }
    if (!aud || !lodash_1.default.isString(aud)) {
        errors.push('"aud" must be a string');
    }
    if (jti && !lodash_1.default.isString(jti)) {
        errors.push('"jti" must be a string');
    }
    if (hsh && !lodash_1.default.isString(hsh)) {
        errors.push('"hsh" must be a string');
    }
    if (!lodash_1.default.isNumber(iat) || iat <= 0) {
        errors.push('"iat" must be a positive number');
    }
    if (!lodash_1.default.isNumber(exp) || exp <= 0) {
        errors.push('"exp" must be a positive number');
    }
    if (exp < iat) {
        errors.push('"exp" must be greater than "iat"');
    }
    if (errors.length) {
        throw Error(`JWT Payload validation ${(0, format_1.pluralize)(errors.length, 'error')}: ${errors.join(',')}.`);
    }
    return { iss, sub, aud, jti, exp, iat, hsh };
}
/**
 * Asserts Jwt protected header is compatible with the ledger Jwt
 * standard header.
 *
 * @param header record with headers
 * @returns parsed Ledger JWT Header
 */
function assertLedgerJwtHeader(header) {
    const { kid, alg } = header;
    const errors = [];
    if (!kid || !lodash_1.default.isString(kid)) {
        errors.push('"kid" must be a string');
    }
    if (!alg || !lodash_1.default.isString(alg)) {
        errors.push('"aud" must be a string');
    }
    if (errors.length) {
        throw Error(`JWT header validation ${(0, format_1.pluralize)(errors.length, 'error')}: ${errors.join(',')}.`);
    }
    return { kid, alg };
}
/**
 * Decodes the provided JWT and returns its payload.
 *
 * @param jwt - The signed JWT
 * @returns {LedgerJWTPayload} Ledger JWT Payload
 */
function decodeJWT(jwt) {
    /**
     * jose.decodeJwt(<jwt>) returns a stantard JWT Claims Set
     * with Registered Claim Names and a custom set of claims.
     * On the other hand, LedgerJWTPayload extends this pattern by opining
     * which of those Registered Claim Names are required
     * and naming explicitly custom claims.
     */
    const jwtPayload = (0, jose_1.decodeJwt)(jwt);
    return assertLedgerJwtPayload(jwtPayload);
}
async function signJWT(payload, secret, kid) {
    return detect_node_1.default
        ? (0, jwt_2.signJWT)(payload, secret, kid)
        : (0, jwt_1.signJWT)(payload, secret, kid);
}
function getJWTProtectedHeader(jwt) {
    const protectedHeaders = detect_node_1.default
        ? (0, jwt_2.getJWTProtectedHeader)(jwt)
        : (0, jwt_1.getJWTProtectedHeader)(jwt);
    return assertLedgerJwtHeader(protectedHeaders);
}
function verifyJWT(jwt, publicKey, format) {
    return detect_node_1.default
        ? (0, jwt_2.verifyJWT)(jwt, publicKey, format)
        : (0, jwt_1.verifyJWT)(jwt, publicKey, format);
}
//# sourceMappingURL=jwt.js.map