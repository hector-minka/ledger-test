"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createKeyPair = createKeyPair;
exports.encryptSecretKey = encryptSecretKey;
exports.decryptSecretKey = decryptSecretKey;
exports.isSecretKeyEncrypted = isSecretKeyEncrypted;
exports.createRsaKeyPair = createRsaKeyPair;
exports.createAesKey = createAesKey;
exports.encryptWithPassword = encryptWithPassword;
exports.decryptWithPassword = decryptWithPassword;
exports.isStringEncryptedPackage = isStringEncryptedPackage;
const detect_node_1 = __importDefault(require("detect-node"));
const keys_1 = require("./browser/keys");
const asn1_1 = require("./common/asn1");
const keys_2 = require("./node/keys");
/**
 * Throws if the current runtime is not Node.js.
 * @param method
 */
function assertNode(method) {
    if (!detect_node_1.default) {
        throw new Error(`${method} is only available in Node.js`);
    }
}
/**
 * Creates a new random key pair for signing ledger
 * requests. Key pair is created using ed25519 algorithm.
 *
 * This function is aware of runtime environment and uses
 * appropriate crypto libraries depending on it. It works both
 * in node and browsers.
 *
 * @returns new key pair
 */
async function createKeyPair() {
    return detect_node_1.default ? (0, keys_2.createKeyPair)() : (0, keys_1.createKeyPair)();
}
/**
 * Encrypts ed25519 secret key with password by using pkcs5
 * specification. Although pkcs5 supports multiple options for
 * digest and encryption algorithms, for our purposes we are
 * using strict choices when encrypting the key:
 * - PBES2 encryption scheme
 * - PBKDF2 key derivation function
 * - SHA-256 digest for deriving key from passphrase
 * - AES-CBC-256 encryption algorithm for encrypting the key
 *
 * @param secret raw base64 encoded ed25519 secret
 * @param password encryption password
 * @returns encrypted secret in pkcs5 format encoded as base64
 * @see https://www.rfc-editor.org/rfc/rfc2898
 */
async function encryptSecretKey(secret, password) {
    return detect_node_1.default
        ? (0, keys_2.encryptSecretKey)(secret, password)
        : (0, keys_1.encryptSecretKey)(secret, password);
}
/**
 * Decrypts ed25519 secret key with password by using pkcs5
 * specification. Although pkcs5 supports multiple options for
 * digest and encryption algorithms, for our purposes we are
 * using strict choices when decrypting the key:
 * - PBES2 encryption scheme
 * - PBKDF2 key derivation function
 * - SHA-256 digest for deriving key from passphrase
 * - AES-CBC-256 encryption algorithm for encrypting the key
 *
 * @param secret encrypted secret in pkcs5 format encoded as base64
 * @param password decryption password
 * @returns raw base64 encoded ed25519 secret
 * @see https://www.rfc-editor.org/rfc/rfc2898
 */
async function decryptSecretKey(secret, password) {
    return detect_node_1.default
        ? (0, keys_2.decryptSecretKey)(secret, password)
        : (0, keys_1.decryptSecretKey)(secret, password);
}
/**
 * Checks if given ed25519 secret is encrypted using pkcs5
 * specification.
 *
 * @param secret secret
 * @returns true if secret is encrypted, false otherwise
 * @see https://www.rfc-editor.org/rfc/rfc2898
 */
function isSecretKeyEncrypted(secret) {
    if (!secret?.length) {
        throw new Error('Secret key is empty');
    }
    return (0, asn1_1.isValidPkcs5EncryptedKey)(Buffer.from(secret, 'base64').toString('hex'));
}
/**
 * Generates a new RSA key pair. This function is only available in Node.js, in browser it is not available.
 * @returns
 */
async function createRsaKeyPair() {
    assertNode('createRsaKeyPair');
    return (0, keys_2.createRsaKeyPair)();
}
/**
 * Generates a new aes key.
 * @returns Base64 encoded string representing the key
 */
async function createAesKey() {
    assertNode('createAesKey');
    return (0, keys_2.createAesKey)();
}
/**
 * Encrypts a given string with a string password. There are no requirements for the format of either.
 * @param secret String to encrypt
 * @param password Password to encrypt with
 * @returns
 */
async function encryptWithPassword(secret, password) {
    assertNode('encryptWithPassword');
    return (0, keys_2.encryptWithPassword)(secret, password);
}
/**
 * Decrypts a given encrypted string with a string password.
 * @param encrypted Components of encrypted string (see `EncryptedString`), or those same components encoded into a string (see `exportEncryptedString` and `importEncryptedString`).
 * @param password Password to decrypt with
 * @returns
 */
async function decryptWithPassword(encrypted, password) {
    assertNode('decryptWithPassword');
    return (0, keys_2.decryptWithPassword)(encrypted, password);
}
/**
 * Checks if a string is a valid encoded `EncryptedString`
 * @param value
 * @returns
 */
function isStringEncryptedPackage(value) {
    if (!value?.length) {
        throw new Error('Value is empty');
    }
    try {
        const parsed = JSON.parse(value);
        const keys = Object.keys(parsed);
        if (keys?.length === 4 &&
            keys.includes('salt') &&
            keys.includes('iterations') &&
            keys.includes('iv') &&
            keys.includes('value')) {
            return true;
        }
        return false;
    }
    catch {
        return false;
    }
}
//# sourceMappingURL=keys.js.map