"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.decryptAES = decryptAES;
exports.encryptAES = encryptAES;
exports.privateDecryptRsa = privateDecryptRsa;
exports.publicEncryptRsa = publicEncryptRsa;
const crypto_1 = require("crypto");
const AES_ALGORITHM = 'aes-256-gcm';
/**
 * Encrypts a payload using the provided RSA public key.
 * @param payload String to encrypt
 * @param publicKey RSA public key
 * @returns Base64 encoded string representing encrypted payload
 */
async function publicEncryptRsa(payload, publicKey) {
    // Convert the payload to a buffer
    const buffer = Buffer.from(payload, 'utf8');
    // Encrypt the payload using the public key
    const encrypted = (0, crypto_1.publicEncrypt)(publicKey, buffer);
    // Convert the encrypted data to a base64 string
    return encrypted.toString('base64');
}
/**
 * Decrypts a payload using the provided RSA private key. Returns the decrypted payload as a UTF-8 string.
 * @param encryptedPayload Base64 encoded string representing encrypted payload
 * @param privateKey
 * @returns UTF-8 encoded string representing decrypted payload
 */
async function privateDecryptRsa(encryptedPayload, privateKey) {
    const buffer = Buffer.from(encryptedPayload, 'base64');
    // Decrypt the payload using the private key
    const decrypted = (0, crypto_1.privateDecrypt)(privateKey, buffer);
    // Convert the decrypted data to a UTF-8 string
    return decrypted.toString('utf8');
}
/**
 * Encrypts a payload using the provided AES key and IV.
 * @param payload String to encrypt
 * @param aesKey Base64 encoded string or a Buffer, representing aes key
 * @param ivHex Optional. Hex encoded string representing IV. If not provided, a random IV will be generated.
 * It is recommended to always use a new IV for each encryption.
 * @returns Object containing the encrypted data, IV, and authentication tag.
 */
function encryptAES(payload, aesKey, ivHex = undefined) {
    const ivBuffer = ivHex ? Buffer.from(ivHex, 'hex') : (0, crypto_1.randomBytes)(16);
    const aesKeyBuffer = typeof aesKey === 'string' ? Buffer.from(aesKey, 'base64') : aesKey;
    const cipher = (0, crypto_1.createCipheriv)(AES_ALGORITHM, aesKeyBuffer, ivBuffer);
    let encrypted = cipher.update(payload, 'utf8', 'hex');
    encrypted += cipher.final('hex');
    // Get the authentication tag
    const authTag = cipher.getAuthTag().toString('hex');
    return { encryptedData: encrypted, iv: ivBuffer.toString('hex'), authTag };
}
/**
 * Decrypts an AES encrypted payload using the provided key and IV.
 * @param encryptedPayload Encoded string representing encrypted payload
 * @param aesKey Base64 encoded string or a Buffer, representing aes key
 * @param ivHex Hex encoded string representing IV
 * @param authTag Hex encoded string representing authentication tag
 * @returns UTF-8 encoded string representing decrypted payload
 */
function decryptAES(encryptedPayload, aesKey, ivHex, authTag) {
    const aesKeyBuffer = typeof aesKey === 'string' ? Buffer.from(aesKey, 'base64') : aesKey;
    const decipher = (0, crypto_1.createDecipheriv)(AES_ALGORITHM, aesKeyBuffer, Buffer.from(ivHex, 'hex'));
    // Set the authentication tag
    decipher.setAuthTag(Buffer.from(authTag, 'hex'));
    let decrypted = decipher.update(encryptedPayload, 'hex', 'utf8');
    decrypted += decipher.final('utf8');
    return decrypted;
}
//# sourceMappingURL=encryption.js.map