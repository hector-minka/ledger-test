"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.signHash = signHash;
exports.verifySignature = verifySignature;
exports.getSignatureKeyFormat = getSignatureKeyFormat;
const detect_node_1 = __importDefault(require("detect-node"));
const asserts_1 = require("./asserts");
const signing_1 = require("./browser/signing");
const hashing_1 = require("./hashing");
const signing_2 = require("./node/signing");
/**
 * Signs the provided hash using the provided private key.
 *
 * @param dataHash data hash to sign, hex encoded
 * @param keyPair key pair to use for signing,
 * @param customData custom data to append to the signature
 * @returns the generated signature
 */
async function signHash(dataHash, keyPair, customData) {
    const digest = (0, hashing_1.createSignatureDigest)(dataHash, customData);
    const signature = detect_node_1.default
        ? await (0, signing_2.signHash)(digest, keyPair)
        : await (0, signing_1.signHash)(digest, keyPair);
    // Avoids setting undefined values
    if (customData) {
        signature.custom = customData;
    }
    return signature;
}
/**
 * Verifies the provided hash signature using the provided public key.
 *
 * @param dataHash data hash that was signed, hex encoded
 * @param signature signature to verify
 * @returns `true` if signature is valid, `false` otherwise
 */
async function verifySignature(dataHash, signature) {
    const digest = (0, hashing_1.createSignatureDigest)(dataHash, signature.custom);
    if (signature.digest !== digest) {
        return false;
    }
    return detect_node_1.default
        ? (0, signing_2.verifySignature)(digest, signature)
        : (0, signing_1.verifySignature)(digest, signature);
}
function getSignatureKeyFormat(method) {
    (0, asserts_1.assertSignatureMethod)(method);
    return 'ed25519-raw';
}
//# sourceMappingURL=signing.js.map