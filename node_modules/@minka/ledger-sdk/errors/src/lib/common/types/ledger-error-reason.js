"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LedgerErrorReasons = exports.LedgerErrorReason = void 0;
/**
 * Supported ledger error statuses.
 */
var LedgerErrorReason;
(function (LedgerErrorReason) {
    // Client errors
    LedgerErrorReason["UnexpectedClientError"] = "unexpected-client-error";
    // Bridge Errors
    LedgerErrorReason["BridgeAccountNotFound"] = "bridge.account-not-found";
    LedgerErrorReason["BridgeAccountInactive"] = "bridge.account-inactive";
    LedgerErrorReason["BridgeAccountInsufficientBalance"] = "bridge.account-insufficient-balance";
    LedgerErrorReason["BridgeAccountLimitExceeded"] = "bridge.account-limit-exceeded";
    LedgerErrorReason["BridgeCoreInvalidAccess"] = "bridge.core-invalid-access";
    LedgerErrorReason["BridgeEntryRejected"] = "bridge.entry-rejected";
    LedgerErrorReason["BridgeEntryHashInvalid"] = "bridge.entry-hash-invalid";
    LedgerErrorReason["BridgeEntrySignatureInvalid"] = "bridge.entry-signature-invalid";
    LedgerErrorReason["BridgeEntrySignatureMismatch"] = "bridge.entry-signature-mismatch";
    LedgerErrorReason["BridgeEntrySignatureMissing"] = "bridge.entry-signature-missing";
    LedgerErrorReason["BridgeEntrySchemaInvalid"] = "bridge.entry-schema-invalid";
    LedgerErrorReason["BridgeEntryMismatch"] = "bridge.entry-mismatch";
    LedgerErrorReason["BridgeEntryDuplicated"] = "bridge.entry-duplicated";
    LedgerErrorReason["BridgeEntryTimeout"] = "bridge.entry-timeout";
    LedgerErrorReason["BridgeIncorrectFee"] = "bridge.incorrect-fee";
    LedgerErrorReason["BridgeIntentHashInvalid"] = "bridge.intent-hash-invalid";
    LedgerErrorReason["BridgeIntentSignatureInvalid"] = "bridge.intent-signature-invalid";
    LedgerErrorReason["BridgeIntentSignatureMissing"] = "bridge.intent-signature-missing";
    LedgerErrorReason["BridgeIntentUnrelated"] = "bridge.intent-unrelated";
    LedgerErrorReason["BridgeFraudDetected"] = "bridge.fraud-detected";
    LedgerErrorReason["BridgeLedgerFailed"] = "bridge.ledger-failed";
    LedgerErrorReason["BridgeCoreUnreachable"] = "bridge.core-unreachable";
    LedgerErrorReason["BridgeTransferInformationInvalid"] = "bridge.transfer-information-invalid";
    LedgerErrorReason["BridgeUnexpectedCoreError"] = "bridge.unexpected-core-error";
    LedgerErrorReason["BridgeUnexpectedError"] = "bridge.unexpected-error";
    LedgerErrorReason["BridgeCommandUnsupported"] = "bridge.command-unsupported";
    LedgerErrorReason["BridgeProxyResponseInvalid"] = "bridge.proxy-response-invalid";
    // Auth Errors
    LedgerErrorReason["AuthUnauthorized"] = "auth.unauthorized";
    LedgerErrorReason["AuthForbidden"] = "auth.forbidden";
    // Crypto Errors
    LedgerErrorReason["CryptoHashInvalid"] = "crypto.hash-invalid";
    LedgerErrorReason["CryptoParentHashInvalid"] = "crypto.parent-hash-invalid";
    LedgerErrorReason["CryptoSignatureInvalid"] = "crypto.signature-invalid";
    LedgerErrorReason["CryptoSignatureMissing"] = "crypto.signature-missing";
    // API Errors
    LedgerErrorReason["ApiBodyMalformed"] = "api.body-malformed";
    LedgerErrorReason["ApiQueryMalformed"] = "api.query-malformed";
    LedgerErrorReason["ApiRouteNotFound"] = "api.route-not-found";
    LedgerErrorReason["ApiRequestTimeout"] = "api.request-timeout";
    LedgerErrorReason["ApiRateLimitExceeded"] = "api.rate-limit-exceeded";
    LedgerErrorReason["ApiUnexpectedError"] = "api.unexpected-error";
    LedgerErrorReason["ApiServiceUnavailable"] = "api.service-unavailable";
    // Record Errors
    LedgerErrorReason["RecordNotFound"] = "record.not-found";
    LedgerErrorReason["RecordRelationNotFound"] = "record.relation-not-found";
    LedgerErrorReason["RecordDropRejected"] = "record.drop-rejected";
    LedgerErrorReason["RecordUpdateRejected"] = "record.update-rejected";
    LedgerErrorReason["RecordDuplicated"] = "record.duplicated";
    LedgerErrorReason["RecordSchemaInvalid"] = "record.schema-invalid";
    LedgerErrorReason["RecordInvalid"] = "record.invalid";
    LedgerErrorReason["RecordLabelsPolicyViolation"] = "record.labels-policy-violation";
    LedgerErrorReason["RecordStatusPolicyViolation"] = "record.status-policy-violation";
    LedgerErrorReason["RecordStatusQuorumNotMet"] = "record.status-quorum-not-met";
    // Core Errors
    LedgerErrorReason["CoreSourceInvalid"] = "core.source-invalid";
    LedgerErrorReason["CoreTargetInvalid"] = "core.target-invalid";
    LedgerErrorReason["CoreSymbolInvalid"] = "core.symbol-invalid";
    LedgerErrorReason["CoreInsufficientBalance"] = "core.insufficient-balance";
    LedgerErrorReason["CoreIntentExpired"] = "core.intent-expired";
    LedgerErrorReason["CoreBridgePrepareFailed"] = "core.bridge-prepare-failed";
    LedgerErrorReason["CoreBridgeUnreachable"] = "core.bridge-unreachable";
    LedgerErrorReason["CoreManualAbortRequested"] = "core.manual-abort-requested";
    LedgerErrorReason["CoreUnexpectedError"] = "core.unexpected-error";
    LedgerErrorReason["CoreRoutingFailed"] = "core.routing-failed";
    LedgerErrorReason["CoreThreadSizeExceeded"] = "core.thread-size-exceeded";
    LedgerErrorReason["CoreLimitExceeded"] = "core.limit-exceeded";
})(LedgerErrorReason || (exports.LedgerErrorReason = LedgerErrorReason = {}));
/**
 * All possible ledger error reasons.
 */
exports.LedgerErrorReasons = Object.values(LedgerErrorReason);
//# sourceMappingURL=ledger-error-reason.js.map