"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.appendLabels = appendLabels;
exports.transformLabels = transformLabels;
exports.setLabels = setLabels;
exports.isLabelAllowedByPolicy = isLabelAllowedByPolicy;
exports.pushLabels = pushLabels;
exports.addToSetLabels = addToSetLabels;
exports.pullLabels = pullLabels;
exports.pullAllLabels = pullAllLabels;
exports.popLabels = popLabels;
exports.calculateLabels = calculateLabels;
const lodash_1 = __importDefault(require("lodash"));
const errors_1 = require("../../../errors/src");
const types_1 = require("../../../types/src");
const validation_1 = require("./validation");
function appendLabels(query, current, labelsAllowedByPolicy) {
    return setLabels(query, current, { labelsAllowedByPolicy });
}
function transformLabels(current, options = {}) {
    let labels = lodash_1.default.clone(current);
    const { $slice, $sort } = options;
    if ($slice) {
        if ($slice > 0) {
            labels = labels.slice(0, $slice);
        }
        else {
            labels = labels.slice($slice);
        }
    }
    if ($sort) {
        labels = labels.sort((l1, l2) => {
            if (l1 > l2) {
                return $sort;
            }
            return $sort * -1;
        });
    }
    return labels;
}
function setLabels(values, current, options = {}) {
    let labels = lodash_1.default.clone(current) || [];
    const { $position, $sort, $slice, labelsAllowedByPolicy } = options;
    const everyLabelIsAllowed = values.every((label) => isLabelAllowedByPolicy(label, labelsAllowedByPolicy));
    if (!everyLabelIsAllowed) {
        const rejectedLabels = lodash_1.default.difference(values, labelsAllowedByPolicy || []);
        const rejectLabelsString = rejectedLabels.join(', ');
        throw new errors_1.RecordLabelsPolicyViolation(`Labels not allowed by policy. Forbidden labels: ${rejectLabelsString}`, {
            labels: rejectedLabels,
        });
    }
    if (!lodash_1.default.isUndefined($position)) {
        labels.splice($position, 0, ...values);
    }
    else {
        labels = lodash_1.default.concat(labels, values);
    }
    return transformLabels(labels, { $slice, $sort });
}
function isLabelAllowedByPolicy(label, labelsAllowedByPolicy) {
    return !labelsAllowedByPolicy || labelsAllowedByPolicy.includes(label);
}
function pushLabels(query, current, labelsAllowedByPolicy) {
    if (lodash_1.default.isString(query.$push)) {
        return setLabels([query.$push], current, {
            labelsAllowedByPolicy,
        });
    }
    const { $position, $sort, $slice, $each } = query.$push;
    return setLabels($each, current, {
        $position,
        $slice,
        $sort,
        labelsAllowedByPolicy,
    });
}
function addToSetLabels(query, current, labelsAllowedByPolicy) {
    const labels = lodash_1.default.clone(current) || [];
    if (lodash_1.default.isString(query.$addToSet)) {
        if (!labels.includes(query.$addToSet)) {
            return setLabels([query.$addToSet], labels, {
                labelsAllowedByPolicy,
            });
        }
        return labels;
    }
    const { $position, $sort, $slice, $each } = query.$addToSet;
    const labelsNotPresent = $each.filter((label) => !labels.includes(label));
    return setLabels(labelsNotPresent, labels, {
        $position,
        $slice,
        $sort,
        labelsAllowedByPolicy,
    });
}
function pullLabels(query, current) {
    let labels = lodash_1.default.clone(current);
    if (lodash_1.default.isString(query.$pull)) {
        return labels.filter((label) => label !== query.$pull);
    }
    const { $sort, $slice, $in } = query.$pull;
    labels = labels.filter((label) => !$in.includes(label));
    return transformLabels(labels, { $sort, $slice });
}
function pullAllLabels(query, current) {
    const labels = lodash_1.default.clone(current);
    return labels.filter((label) => !query.$pullAll.includes(label));
}
function popLabels(query, current) {
    const labels = lodash_1.default.clone(current);
    query.$pop === types_1.PopValue.End ? labels.pop() : labels.shift();
    return labels;
}
function calculateLabels(query, current, labelsAllowedByPolicy) {
    if ((0, validation_1.isSimpleLabelsQuery)(query)) {
        return appendLabels(query, current, labelsAllowedByPolicy);
    }
    if ((0, validation_1.isLabelsQueryPush)(query)) {
        return pushLabels(query, current, labelsAllowedByPolicy);
    }
    if ((0, validation_1.isLabelsQueryAddToSet)(query)) {
        return addToSetLabels(query, current, labelsAllowedByPolicy);
    }
    if ((0, validation_1.isLabelsQueryPull)(query)) {
        return pullLabels(query, current);
    }
    if ((0, validation_1.isLabelsQueryPullAll)(query)) {
        return pullAllLabels(query, current);
    }
    if ((0, validation_1.isLabelsQueryPop)(query)) {
        return popLabels(query, current);
    }
    return current;
}
//# sourceMappingURL=labels.functions.js.map