"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ninMatcher = exports.inMatcher = exports.regexMatcher = void 0;
exports.isMatch = isMatch;
exports.isActionMatch = isActionMatch;
const lodash_1 = require("lodash");
const mingo_1 = require("mingo");
const types_1 = require("../../../types/src");
const validation_1 = require("./validation");
class UnsupportedFilterType extends Error {
    constructor(filterType) {
        super(`Unsupported filter type: ${filterType}`);
    }
}
class InvalidRegexError extends Error {
    constructor(message) {
        super(message);
    }
}
class InvalidArrayError extends Error {
    constructor(message) {
        super(message);
    }
}
/**
 * Gets regexp object from string or throw if it's invalid.
 */
function getRegex(regex) {
    try {
        return new RegExp(regex);
    }
    catch (e) {
        throw new InvalidRegexError(`Invalid regex ${regex}`);
    }
}
/**
 * Checks if provided value matches the regex given as string.
 */
const regexMatcher = (item, expression) => {
    const regex = getRegex(expression);
    return regex.test(item);
};
exports.regexMatcher = regexMatcher;
/**
 * Loads the values from an array or object or throw
 * if given value if neither of them.
 */
function getItems(expression) {
    if (!Array.isArray(expression)) {
        throw new InvalidArrayError('Invalid array');
    }
    return expression;
}
/**
 * Checks if provided value is in the array or object provided.
 */
const inMatcher = (item, expression) => {
    const items = getItems(expression);
    return items.includes(item);
};
exports.inMatcher = inMatcher;
/**
 * Checks if provided value is not in the array or object provided.
 */
const ninMatcher = (item, expression) => {
    const items = getItems(expression);
    return !items.includes(item);
};
exports.ninMatcher = ninMatcher;
/**
 * Check if data matches the given filter. It supports
 * exact match and also the $in and $regex operators which
 * work similarly to MongoDB. The left side of the expression
 * is the expected value to match in dot notation, and the
 * right side is the filter.
 *
 * Examples:
 *
 *  { 'person.name': { $regex: /Ë†J/ } }
 *
 *  { 'person.lastName': { $in: ['Smith', 'Doe'] } }
 *
 *  { 'person.name': 'Jhon' }
 * @param data Data to be checked against
 * @param filter Filter to be applied
 * @returns {boolean} true if data matches the filter
 */
function isMatch(data, filter) {
    for (const key in filter) {
        const item = (0, lodash_1.get)(data, key);
        const expression = filter[key];
        // If type is an expression, check which types it has
        if (typeof expression === 'object') {
            for (const type in expression) {
                const expressionValue = expression[type];
                if (type === '$regex') {
                    if (!(0, exports.regexMatcher)(item, expressionValue)) {
                        return false;
                    }
                    continue;
                }
                if (type === '$in') {
                    if (!(0, exports.inMatcher)(item, expressionValue)) {
                        return false;
                    }
                    continue;
                }
                if (type === '$nin') {
                    if (!(0, exports.ninMatcher)(item, expressionValue)) {
                        return false;
                    }
                    continue;
                }
                throw new UnsupportedFilterType(type);
            }
            continue;
        }
        if (item !== expression) {
            return false;
        }
    }
    return true;
}
/**
 * Determines whether access rule actions are included or excluded
 * by evaluating a match expression against a given query expression.
 *
 * @param {Object} matchExpression - The expression used to evaluate matches.
 * @param {Object} actionExpression - The access rule action expression to compare.
 *
 * @returns {boolean} - Returns `true` if the match expression includes or excludes
 *                      the actions as per the query; otherwise, `false`.
 */
function isActionMatch(matchExpression, actionExpression) {
    let actionsToMatch;
    if ((0, validation_1.isInAggregation)(actionExpression)) {
        actionsToMatch = actionExpression.$in;
    }
    else if ((0, validation_1.isNinAggregation)(actionExpression)) {
        if (actionExpression.$nin.includes(types_1.AccessAction.Any)) {
            actionsToMatch = [];
        }
        else {
            const excludedActions = actionExpression.$nin;
            actionsToMatch = types_1.AccessActions.filter((action) => {
                return !excludedActions.includes(action);
            });
        }
    }
    else {
        actionsToMatch = [actionExpression];
    }
    const query = new mingo_1.Query({
        action: matchExpression,
    });
    return query.test({
        action: actionsToMatch,
    });
}
//# sourceMappingURL=matcher.js.map