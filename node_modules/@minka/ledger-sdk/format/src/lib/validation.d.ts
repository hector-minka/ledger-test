import Ajv from 'ajv';
import { AccessPolicyValue, AccessRecord, Aggregation, InAggregation, LedgerAccessRule, LedgerLabel, LedgerLabelAddToSet, LedgerLabelPull, LedgerLabelPullAll, LedgerLabelPush, LedgerLabelQuery, LedgerLuid, LedgerPolicyRule, NinAggregation, Pop, RegexMatch, SchemaContent } from "../../../types/src";
/**
 * Asserts that a value isn't an empty string.
 * @param value value to validate
 * @param errorMessage
 */
export declare function assertNotEmptyString(value: string, errorMessage?: string): void;
export declare const secretRefPattern: RegExp;
/**
 * Asserts that a value is an inline secret reference.
 * @param value value to validate
 * @param errorMessage
 */
export declare function assertIsInlineSecretRef(value: string, errorMessage?: string): void;
/**
 * Asserts that a value is not an inline secret reference.
 * @param value value to validate
 * @param errorMessage
 */
export declare function assertNotInlineSecretRef(value: string, errorMessage?: string): void;
/**
 * Regular expression which matches record handle.
 *
 * Handle can consist of lowercase and uppercase letters, digits,
 * and special characters: _, -, :, ., =, $, /, +. Handle should not
 * start with `$<3 letters>.` prefix because this pattern is designated
 * for LUID.
 */
export declare const HANDLE_REGEX: RegExp;
/**
 * Regular expression which matches the address used in source,
 * target or wallet handle.
 *
 * Address format consists of schema,
 * handle and domain: `[<schema>:]<handle>[@<domain>]`.
 * Schema and domain parts are optional, but all 3 components
 * can consist only of lowercase and uppercase letters,
 * digits and special characters ., _, - and +.
 *
 * Regex exec result will have 3 named groups where components
 * will be parsed (if present):
 * ```
 * - schema
 * - handle
 * - domain
 * ```
 * @example
 * const result = ADDRESS_REGEX.exec('tran:12345@pbz.hr')
 *
 * if (result) {
 *   const { schema, handle, domain } = result.groups
 * }
 * // { schema: 'tran', handle: '12345', domain: 'pbz.hr' }
 */
export declare const ADDRESS_REGEX: RegExp;
/**
 * Regular expression which matches the luid.
 * Its pattern is defined by:
 *
 * `$<3 chars abbreviation of record type>.<17 random chars>`
 *
 * The random chars can be lowercase and uppercase letters, digits,
 * _ and -.
 * @example
 * // for wallets
 * luid: $wlt.7mSVWFKX-Tfx2NsNj
 * @example
 * // for circles
 * luid: $crc.2mLt0MgoHi_DrLr9X
 */
export declare const LUID_REGEX: RegExp;
/**
 * Regular expression which matches the allowed field name
 * used in ledger custom data or filters.
 * Field name can consist of lowercase and uppercase letters, digits,
 * and special characters: _, -, . and it should start only with
 * lowercase letter.
 */
export declare const FIELD_NAME_REGEX: RegExp;
export type IdentifierFormat = 'handle' | 'address' | 'fieldName';
/**
 * Validates that a provided value is a valid identifier.
 * Accepts an optional format parameter with the following values:
 * - handle: identifier of most records in ledger (except wallet)
 * - address: structured identifier for targeting wallets in intents
 * - fieldName: field name used in simple maps such as custom data and filters
 * @param value value to validate
 * @param [format] format of the identifier
 */
export declare function assertValidIdentifier(value: string, format?: IdentifierFormat): boolean;
/**
 * Validates that a provided value is a valid number.
 * @param value value to validate
 */
export declare function assertNumber(value: number | string): void;
/**
 * Validates that a provided value is an integer number.
 * @param value value to validate
 */
export declare function assertInteger(value: number): void;
/**
 * Validates that the provided number is larger than the
 * provided min value.
 * @param value value to validate
 * @param minValue min value to compare against
 */
export declare function assertGreaterThan(value: number, minValue: number): void;
/**
 * Validates that the provided number is larger than or equal the
 * provided min value.
 * @param value value to validate
 * @param minValue min value to compare against
 */
export declare function assertGreaterThanOrEqual(value: number, minValue: number): void;
/**
 * Validates that the provided number is less than or equal the
 * provided max value.
 * @param value value to validate
 * @param maxValue max value to compare against
 */
export declare function assertLessThanOrEqual(value: number, maxValue: number): void;
/**
 * Validates that the provided number is power of 10.
 * @param value value to validate
 */
export declare function assertPowerOf10(value: number): void;
/**
 * Validates that the provided number in integer when multiplied
 * by factor.
 * @param value value to validate
 * @param factor factor to multiply with
 */
export declare function assertValidWithFactor(value: number, factor: number): void;
/**
 * Validates that the correct number of values has been selected. This
 * validator is useful for checkbox style inputs.
 * @param selection selected values
 * @param requiredOptions required number of selected values
 */
export declare function assertOptionsSelected(selection: any[], requiredOptions?: number): void;
/**
 * Asserts that a value isn't an empty string.
 * @param value value to validate
 * @param url
 */
export declare function assertValidUrl(url: string): void;
/**
 * Validates that the provided value exists in the provided
 * array
 * @param value value to validate
 * @param array array to compare against
 */
export declare function assertContains(value: any, array: Array<any>): void;
/**
 * Checks whether a value is a luid pattern string
 * @param value value to be checked
 * @returns
 */
export declare function isLuid(value: string): value is LedgerLuid;
/**
 * Checks whether a value is a valid ed25519-raw public key
 * @param value
 */
export declare function assertIsPublicKey(value: string): void;
/**
 * Checks whether a value is a valid ed25519-raw secret key
 * @param value
 */
export declare function assertIsSecretKey(value: string): void;
/**
 * Checks if a label query is LedgerLabel[]
 * @param query label query
 * @returns boolean
 */
export declare function isSimpleLabelsQuery(query: LedgerLabelQuery): query is LedgerLabel[];
/**
 * Checks if a label query is of type LedgerLabelPush
 * @param query label query
 * @returns boolean
 */
export declare function isLabelsQueryPush(query: LedgerLabelQuery): query is LedgerLabelPush;
/**
 * Checks if a label query is of type LedgerLabelAddToSet
 * @param query label query
 * @returns boolean
 */
export declare function isLabelsQueryAddToSet(query: LedgerLabelQuery): query is LedgerLabelAddToSet;
/**
 * Checks if a label query is of type isLabelsQueryPull
 * @param query label query
 * @returns boolean
 */
export declare function isLabelsQueryPull(query: LedgerLabelQuery): query is LedgerLabelPull;
/**
 * Checks if a label query is of type isLabelsQueryPullAll
 * @param query label query
 * @returns boolean
 */
export declare function isLabelsQueryPullAll(query: LedgerLabelQuery): query is LedgerLabelPullAll;
/**
 * Checks if a label query is of type isLabelsQueryPop
 * @param query label query
 * @returns boolean
 */
export declare function isLabelsQueryPop(query: LedgerLabelQuery): query is Pop;
/**
 * Checks if provided element is an aggregation
 * of type T or just T.
 * @param obj element to be checked
 * @param aggregator aggregation operator
 * @returns true if {obj} is Aggregation of T
 *          false if {obj} is T
 */
export declare function isAggregation<T>(obj: T | Aggregation<T>, aggregator?: '$nin' | '$in'): obj is Aggregation<T>;
/**
 * Checks if provided element is an aggregation ($in)
 * of type T or just T.
 * @param obj element to be checked
 * @returns true if {obj} is InAggregation of T
 *          false if {obj} is T
 */
export declare function isInAggregation<T>(obj: T | InAggregation<T>): obj is InAggregation<T>;
/**
 * Checks if provided element is a regex match expression ($regex)
 * @param obj element to be checked
 * @returns true if {obj} is regex match expression
 *          false otherwise
 */
export declare function isRegexMatchExpression(obj: unknown | RegexMatch): obj is RegexMatch;
/**
 * Checks if provided element is an aggregation ($in)
 * of type T or just T.
 * @param obj element to be checked
 * @returns true if {obj} is NinAggregation of T
 *          false if {obj} is T
 */
export declare function isNinAggregation<T>(obj: T | NinAggregation<T>): obj is NinAggregation<T>;
/**
 * Checks if provided access rule is a policy.
 * @param accessRule
 * @returns
 */
export declare function isPolicyRule(accessRule: LedgerAccessRule | LedgerPolicyRule): accessRule is LedgerPolicyRule;
/**
 * Asserts access policy values
 * @param policyRecord root policy record
 * @param values policy values
 */
export declare function assertAccessPolicyValues(policyRecord: AccessRecord, values: AccessPolicyValue[]): void;
/**
 * Asserts that a value is a valid timezone using the MomentTZ API.
 * @param tz Timezone to validate
 */
export declare function isValidTimezone(tz: string): boolean;
/**
 * Register custom formats to AJV instance.
 * @param ajv AJV instance
 */
export declare function addMinkaFormats(ajv: Ajv): void;
/**
 * Validates data against a JSON schema.
 * @param schema - The JSON schema to validate against.
 * @param data - The data to validate.
 */
export declare function validateJsonSchema(schema: SchemaContent, data: any): Promise<void>;
/**
 * Asserts that a JSON schema is valid.
 * @param schema - The JSON schema to validate.
 */
export declare function assertJsonSchemaDefinitions(schema: SchemaContent): Promise<void>;
