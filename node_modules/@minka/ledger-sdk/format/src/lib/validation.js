"use strict";
// This file contains validator functions that can be used
// to validate user input in commands. Functions return void
// if the provided value is valid, or throw an Error if the
// value isn't valid.
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FIELD_NAME_REGEX = exports.LUID_REGEX = exports.ADDRESS_REGEX = exports.HANDLE_REGEX = exports.secretRefPattern = void 0;
exports.assertNotEmptyString = assertNotEmptyString;
exports.assertIsInlineSecretRef = assertIsInlineSecretRef;
exports.assertNotInlineSecretRef = assertNotInlineSecretRef;
exports.assertValidIdentifier = assertValidIdentifier;
exports.assertNumber = assertNumber;
exports.assertInteger = assertInteger;
exports.assertGreaterThan = assertGreaterThan;
exports.assertGreaterThanOrEqual = assertGreaterThanOrEqual;
exports.assertLessThanOrEqual = assertLessThanOrEqual;
exports.assertPowerOf10 = assertPowerOf10;
exports.assertValidWithFactor = assertValidWithFactor;
exports.assertOptionsSelected = assertOptionsSelected;
exports.assertValidUrl = assertValidUrl;
exports.assertContains = assertContains;
exports.isLuid = isLuid;
exports.assertIsPublicKey = assertIsPublicKey;
exports.assertIsSecretKey = assertIsSecretKey;
exports.isSimpleLabelsQuery = isSimpleLabelsQuery;
exports.isLabelsQueryPush = isLabelsQueryPush;
exports.isLabelsQueryAddToSet = isLabelsQueryAddToSet;
exports.isLabelsQueryPull = isLabelsQueryPull;
exports.isLabelsQueryPullAll = isLabelsQueryPullAll;
exports.isLabelsQueryPop = isLabelsQueryPop;
exports.isAggregation = isAggregation;
exports.isInAggregation = isInAggregation;
exports.isRegexMatchExpression = isRegexMatchExpression;
exports.isNinAggregation = isNinAggregation;
exports.isPolicyRule = isPolicyRule;
exports.assertAccessPolicyValues = assertAccessPolicyValues;
exports.isValidTimezone = isValidTimezone;
exports.addMinkaFormats = addMinkaFormats;
exports.validateJsonSchema = validateJsonSchema;
exports.assertJsonSchemaDefinitions = assertJsonSchemaDefinitions;
const ajv_1 = __importDefault(require("ajv"));
const ajv_formats_1 = __importDefault(require("ajv-formats"));
const bignumber_js_1 = require("bignumber.js");
const lodash_1 = __importDefault(require("lodash"));
const moment_timezone_1 = __importDefault(require("moment-timezone"));
const errors_1 = require("../../../errors/src");
const types_1 = require("../../../types/src");
/**
 * Asserts that a value isn't an empty string.
 * @param value value to validate
 * @param errorMessage
 */
function assertNotEmptyString(value, errorMessage) {
    if (typeof value !== 'string' || value === '') {
        throw new Error(errorMessage || `Value cannot be empty.`);
    }
}
exports.secretRefPattern = /\{\{\s*secret\.([A-Za-z]+[A-Za-z0-9]*)\s*\}\}/;
/**
 * Asserts that a value is an inline secret reference.
 * @param value value to validate
 * @param errorMessage
 */
function assertIsInlineSecretRef(value, errorMessage) {
    if (typeof value !== 'string' || value === '') {
        throw new Error(errorMessage || `Value cannot be empty.`);
    }
    if (!exports.secretRefPattern.test(value)) {
        throw new Error(errorMessage ||
            `Value must be a secret reference, for example '{{ secret.mySecret }}'.`);
    }
}
/**
 * Asserts that a value is not an inline secret reference.
 * @param value value to validate
 * @param errorMessage
 */
function assertNotInlineSecretRef(value, errorMessage) {
    if (typeof value !== 'string' || value === '') {
        throw new Error(errorMessage || `Value cannot be empty.`);
    }
    if (exports.secretRefPattern.test(value)) {
        throw new Error(errorMessage ||
            `Value cannot be a secret reference, for example it cannot be '{{ secret.mySecret }}'.`);
    }
}
// Regular expressions below are reused, be careful if
// you decide to add /g flag, because regex would become
// stateful in that case and could work unreliably.
/**
 * Regular expression which matches record handle.
 *
 * Handle can consist of lowercase and uppercase letters, digits,
 * and special characters: _, -, :, ., =, $, /, +. Handle should not
 * start with `$<3 letters>.` prefix because this pattern is designated
 * for LUID.
 */
exports.HANDLE_REGEX = /^(?!\$[a-z]{3}\.)[a-zA-Z0-9_\-:.=$/+]+$/;
/**
 * Regular expression which matches the address used in source,
 * target or wallet handle.
 *
 * Address format consists of schema,
 * handle and domain: `[<schema>:]<handle>[@<domain>]`.
 * Schema and domain parts are optional, but all 3 components
 * can consist only of lowercase and uppercase letters,
 * digits and special characters ., _, - and +.
 *
 * Regex exec result will have 3 named groups where components
 * will be parsed (if present):
 * ```
 * - schema
 * - handle
 * - domain
 * ```
 * @example
 * const result = ADDRESS_REGEX.exec('tran:12345@pbz.hr')
 *
 * if (result) {
 *   const { schema, handle, domain } = result.groups
 * }
 * // { schema: 'tran', handle: '12345', domain: 'pbz.hr' }
 */
exports.ADDRESS_REGEX = /^(((?<schema>[a-zA-Z0-9_\-+.]+):)?(?<handle>[a-zA-Z0-9_\-+.]+))(@(?<domain>[a-zA-Z0-9_\-+.]+))?$/;
/**
 * Regular expression which matches the luid.
 * Its pattern is defined by:
 *
 * `$<3 chars abbreviation of record type>.<17 random chars>`
 *
 * The random chars can be lowercase and uppercase letters, digits,
 * _ and -.
 * @example
 * // for wallets
 * luid: $wlt.7mSVWFKX-Tfx2NsNj
 * @example
 * // for circles
 * luid: $crc.2mLt0MgoHi_DrLr9X
 */
exports.LUID_REGEX = /^\$[a-z]{3}\.[A-Za-z0-9_-]{17}$/;
/**
 * Regular expression which matches the allowed field name
 * used in ledger custom data or filters.
 * Field name can consist of lowercase and uppercase letters, digits,
 * and special characters: _, -, . and it should start only with
 * lowercase letter.
 */
exports.FIELD_NAME_REGEX = /^[a-z][a-zA-Z0-9_\-.]+$/;
/**
 * Validates that a provided value is a valid identifier.
 * Accepts an optional format parameter with the following values:
 * - handle: identifier of most records in ledger (except wallet)
 * - address: structured identifier for targeting wallets in intents
 * - fieldName: field name used in simple maps such as custom data and filters
 * @param value value to validate
 * @param [format] format of the identifier
 */
function assertValidIdentifier(value, format = 'handle') {
    assertNotEmptyString(value);
    switch (format) {
        case 'handle':
            if (isLuid(value)) {
                throw new Error(`Cannot use luid-based identifier as a handle.`);
            }
            return true;
        case 'address':
            if (isLuid(value)) {
                throw new Error(`Cannot use luid-based identifier as an address.`);
            }
            return true;
        case 'fieldName':
            if (!exports.FIELD_NAME_REGEX.test(value)) {
                throw new Error(`Only values with letters, digits, _, -, and . that start with a lowercase letter are allowed.`);
            }
            break;
    }
}
/**
 * Validates that a provided value is a valid number.
 * @param value value to validate
 */
function assertNumber(value) {
    const parsedValue = typeof value === 'string' ? Number(value) : value;
    const isValid = typeof parsedValue === 'number' && !isNaN(parsedValue);
    if (!isValid) {
        throw new Error(`Please enter a valid number.`);
    }
}
/**
 * Validates that a provided value is an integer number.
 * @param value value to validate
 */
function assertInteger(value) {
    if (!lodash_1.default.isInteger(value)) {
        throw new Error(`Value must be integer.`);
    }
}
/**
 * Validates that the provided number is larger than the
 * provided min value.
 * @param value value to validate
 * @param minValue min value to compare against
 */
function assertGreaterThan(value, minValue) {
    if (value <= minValue) {
        throw new Error(`Value must be greater than ${minValue}`);
    }
}
/**
 * Validates that the provided number is larger than or equal the
 * provided min value.
 * @param value value to validate
 * @param minValue min value to compare against
 */
function assertGreaterThanOrEqual(value, minValue) {
    if (value < minValue) {
        throw new Error(`Value must be greater than or equal ${minValue}`);
    }
}
/**
 * Validates that the provided number is less than or equal the
 * provided max value.
 * @param value value to validate
 * @param maxValue max value to compare against
 */
function assertLessThanOrEqual(value, maxValue) {
    if (value > maxValue) {
        throw new Error(`Value must be less than or equal ${maxValue}`);
    }
}
/**
 * Validates that the provided number is power of 10.
 * @param value value to validate
 */
function assertPowerOf10(value) {
    if (Math.log10(value) % 1 !== 0) {
        throw new Error(`Value must be a power of 10`);
    }
}
/**
 * Validates that the provided number in integer when multiplied
 * by factor.
 * @param value value to validate
 * @param factor factor to multiply with
 */
function assertValidWithFactor(value, factor) {
    const bnValue = new bignumber_js_1.BigNumber(value).times(new bignumber_js_1.BigNumber(factor));
    // we cannot just multiply value with factor and check if that is an integer
    // as this is vulnerable to bugs in javascript when multiplying floats
    const isValid = bnValue.integerValue().isEqualTo(bnValue);
    if (!isValid) {
        throw new Error(`Smallest unit of amount can be ${1 / factor}`);
    }
}
/**
 * Validates that the correct number of values has been selected. This
 * validator is useful for checkbox style inputs.
 * @param selection selected values
 * @param requiredOptions required number of selected values
 */
function assertOptionsSelected(selection, requiredOptions = 1) {
    if (!selection || selection.length < requiredOptions) {
        throw new Error(`Please select at least ${requiredOptions} option${requiredOptions > 1 ? 's' : ''}`);
    }
}
/**
 * Asserts that a value isn't an empty string.
 * @param value value to validate
 * @param url
 */
function assertValidUrl(url) {
    try {
        new URL(url);
    }
    catch (e) {
        throw new Error(`Value ${url} is not a valid URL.`);
    }
}
/**
 * Validates that the provided value exists in the provided
 * array
 * @param value value to validate
 * @param array array to compare against
 */
function assertContains(value, array) {
    if (!array.includes(value)) {
        throw new Error(`Value must be one of ${array.join(', ')}`);
    }
}
/**
 * Checks whether a value is a luid pattern string
 * @param value value to be checked
 * @returns
 */
function isLuid(value) {
    return exports.LUID_REGEX.test(value);
}
/**
 * Checks whether a value is a valid ed25519-raw public key
 * @param value
 */
function assertIsPublicKey(value) {
    if (!/^[A-Za-z0-9+/]{43}=$/.test(value)) {
        throw new Error(`Value ${value} is not a valid public key.`);
    }
}
/**
 * Checks whether a value is a valid ed25519-raw secret key
 * @param value
 */
function assertIsSecretKey(value) {
    if (!/^[A-Za-z0-9+/]{43}=$/.test(value)) {
        throw new Error(`Value ${value} is not a valid secret key.`);
    }
}
/**
 * Checks if a label query is LedgerLabel[]
 * @param query label query
 * @returns boolean
 */
function isSimpleLabelsQuery(query) {
    return lodash_1.default.isArray(query);
}
/**
 * Checks if a label query is of type LedgerLabelPush
 * @param query label query
 * @returns boolean
 */
function isLabelsQueryPush(query) {
    return !!query.$push;
}
/**
 * Checks if a label query is of type LedgerLabelAddToSet
 * @param query label query
 * @returns boolean
 */
function isLabelsQueryAddToSet(query) {
    return !!query.$addToSet;
}
/**
 * Checks if a label query is of type isLabelsQueryPull
 * @param query label query
 * @returns boolean
 */
function isLabelsQueryPull(query) {
    return !!query.$pull;
}
/**
 * Checks if a label query is of type isLabelsQueryPullAll
 * @param query label query
 * @returns boolean
 */
function isLabelsQueryPullAll(query) {
    return !!query.$pullAll;
}
/**
 * Checks if a label query is of type isLabelsQueryPop
 * @param query label query
 * @returns boolean
 */
function isLabelsQueryPop(query) {
    return !!query.$pop;
}
/**
 * Checks if provided element is an aggregation
 * of type T or just T.
 * @param obj element to be checked
 * @param aggregator aggregation operator
 * @returns true if {obj} is Aggregation of T
 *          false if {obj} is T
 */
function isAggregation(obj, aggregator = '$in') {
    return obj && obj[aggregator] !== undefined;
}
/**
 * Checks if provided element is an aggregation ($in)
 * of type T or just T.
 * @param obj element to be checked
 * @returns true if {obj} is InAggregation of T
 *          false if {obj} is T
 */
function isInAggregation(obj) {
    return isAggregation(obj);
}
/**
 * Checks if provided element is a regex match expression ($regex)
 * @param obj element to be checked
 * @returns true if {obj} is regex match expression
 *          false otherwise
 */
function isRegexMatchExpression(obj) {
    return obj && !!obj.$regex;
}
/**
 * Checks if provided element is an aggregation ($in)
 * of type T or just T.
 * @param obj element to be checked
 * @returns true if {obj} is NinAggregation of T
 *          false if {obj} is T
 */
function isNinAggregation(obj) {
    return isAggregation(obj, '$nin');
}
/**
 * Checks if provided access rule is a policy.
 * @param accessRule
 * @returns
 */
function isPolicyRule(accessRule) {
    return accessRule.policy !== undefined;
}
/**
 * Asserts access policy values
 * @param policyRecord root policy record
 * @param values policy values
 */
function assertAccessPolicyValues(policyRecord, values) {
    const invalidValue = values.find((value) => {
        const resolvedRecord = value.record || policyRecord;
        let flatRecords = [];
        if (isInAggregation(resolvedRecord)) {
            resolvedRecord.$in.forEach((recordIncluded) => {
                if (recordIncluded === types_1.AccessRecord.Any) {
                    flatRecords.push(...types_1.AccessRecords.filter((accessRecordAvailable) => accessRecordAvailable !== types_1.AccessRecord.Any));
                }
                else {
                    flatRecords.push(recordIncluded);
                }
            });
        }
        else {
            flatRecords.push(resolvedRecord);
        }
        flatRecords = lodash_1.default.uniq(flatRecords);
        return (value.invoke &&
            flatRecords.some((record) => {
                const invokeAlternatives = types_1.InvokeRecordAlternatives[record] || [];
                return !invokeAlternatives.includes(value.invoke);
            }));
    });
    if (invalidValue) {
        const errorRecord = invalidValue.record || policyRecord;
        let recordString;
        if (isInAggregation(errorRecord)) {
            recordString = `records included in [${errorRecord.$in}]`;
        }
        else {
            recordString = `record ${errorRecord}`;
        }
        throw new errors_1.RecordInvalid(`Cannot set invoke ${invalidValue.invoke} to an access rule of ${recordString}`);
    }
}
/**
 * Asserts that a value is a valid timezone using the MomentTZ API.
 * @param tz Timezone to validate
 */
function isValidTimezone(tz) {
    return !!moment_timezone_1.default.tz.zone(tz);
}
/**
 * Register custom formats to AJV instance.
 * @param ajv AJV instance
 */
function addMinkaFormats(ajv) {
    ajv.addFormat('timezone', isValidTimezone);
}
const factoryAjv = () => {
    const ajv = new ajv_1.default({
        allErrors: true,
        discriminator: true,
        /**
         * This option is used to allow us to use tuples (items property)
         * notation to define array schemas for some items and allow
         * additional items.
         * See more: https://ajv.js.org/strict-mode.html#unconstrained-tuples
         *
         * Note: Otherwise nothing fails, it's just a warning that gets
         * logged in the console.
         */
        strictTuples: false,
        keywords: ['key-pair'],
        logger: false,
        strict: false,
    });
    (0, ajv_formats_1.default)(ajv);
    addMinkaFormats(ajv);
    return ajv;
};
/**
 * Validates data against a JSON schema.
 * @param schema - The JSON schema to validate against.
 * @param data - The data to validate.
 */
async function validateJsonSchema(schema, data) {
    try {
        // Validate data against schema
        const ajv = factoryAjv();
        const validate = ajv.compile(schema);
        const valid = validate(data);
        if (!valid) {
            const message = validate.errors
                .map((error) => {
                return `data${error.instancePath.replaceAll('/', '.')} ${error.message}`;
            })
                .join(', ');
            throw new Error(message);
        }
    }
    catch (error) {
        throw new Error(`Schema validation error: ${error.message || undefined}`);
    }
}
/**
 * Asserts that a JSON schema is valid.
 * @param schema - The JSON schema to validate.
 */
async function assertJsonSchemaDefinitions(schema) {
    try {
        const ajv = factoryAjv();
        // Validate that schema can be parsed by AJV
        ajv.compile(schema);
    }
    catch (error) {
        throw new Error(`Schema provided is not a valid json-schema: ${error.message || undefined}`);
    }
}
//# sourceMappingURL=validation.js.map