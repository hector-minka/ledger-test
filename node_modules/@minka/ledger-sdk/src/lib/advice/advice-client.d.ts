/**
 * @module Clients / Advices
 * @category Entities
 */
import { AxiosResponse } from 'axios';
import { AdviceAliasResolve, AdviceAliasResolveResult, LedgerRecord } from "../../../types/src";
import { BaseClient } from '../common/clients/base-client';
import { CreateRecordBuilder } from '../common/services/create-record-builder';
import { BaseRecordResponse } from '../common/types/base-record-response';
export declare enum AdviceName {
    AliasResolve = "alias-resolve"
}
/**
 * Single advice API response.
 */
export declare class AdviceAliasResolveResponse extends BaseRecordResponse<AdviceAliasResolveResult> {
    /**
     * Record data extracted from the `data` property of the response body.
     */
    result: AdviceAliasResolveResult;
    constructor(response: AxiosResponse<LedgerRecord<AdviceAliasResolveResult>, LedgerRecord<AdviceAliasResolveResult>>);
}
/**
 * Allows executing advices.
 *
 * @see {AdviceAliasResolveResult}
 */
export declare class AdviceClient extends BaseClient {
    /**
     * Initializes a builder instance that supports chaining to make it
     * easier to work with ledger records. You can pass the record
     * payload to this method to use as initial content, this is useful
     * when you already have an object ready, for example when validating
     * API responses or modifying an existing record. An empty record is
     * going to be created if no initial data is provided.
     *
     * @see {AdviceAliasResolveResult}
     * @see {CreateRecordBuilder}
     * @param name advice name
     * @param record initial payload for advice call
     * @returns a builder instance
     */
    call(name: AdviceName, record?: Partial<LedgerRecord<AdviceAliasResolve>>): CreateRecordBuilder<unknown, AdviceAliasResolveResponse, import("../../../types/src").LedgerMeta>;
}
