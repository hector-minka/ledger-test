"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CircleSignerClient = exports.CircleSignersResponse = exports.CircleSignerResponse = void 0;
const lodash_1 = __importDefault(require("lodash"));
const base_client_1 = require("../common/clients/base-client");
const create_record_builder_1 = require("../common/services/create-record-builder");
const drop_record_builder_1 = require("../common/services/drop-record-builder");
const base_record_response_1 = require("../common/types/base-record-response");
const list_response_1 = require("../common/types/list-response");
const CIRCLE_SIGNER_LINK_PATH = 'signers';
/**
 * Single signer API response.
 */
class CircleSignerResponse extends base_record_response_1.BaseRecordResponse {
    /**
     * Record data extracted from the `data` property of the response body.
     */
    circleSigner;
    constructor(response) {
        super(response);
        this.circleSigner = response?.data?.data;
    }
}
exports.CircleSignerResponse = CircleSignerResponse;
/**
 * CircleSignerLinks list API response.
 */
class CircleSignersResponse extends list_response_1.BaseListResponse {
    circleSigners;
    constructor(response) {
        super(response);
        this.circleSigners = response?.data?.data?.map((record) => record.data);
    }
}
exports.CircleSignersResponse = CircleSignersResponse;
/**
 * Allows querying and managing signers.
 *
 * @see {LedgerCircleSigner}
 */
class CircleSignerClient extends base_client_1.BaseClient {
    parentPath;
    constructor(options, parentPath) {
        super(options);
        this.parentPath = parentPath;
    }
    buildBasePath() {
        const circle = this.assertParentId();
        return `${this.parentPath}/${encodeURIComponent(circle)}/${CIRCLE_SIGNER_LINK_PATH}`;
    }
    /**
     * Initializes a builder instance that supports chaining to make it
     * easier to work with ledger records. You can pass the record
     * payload to this method to use as initial content, this is useful
     * when you already have an object ready, for example when validating
     * API responses or modifying an existing record. An empty record is
     * going to be created if no initial data is provided.
     *
     * @see {LedgerCircleSigner}
     * @see {CreateRecordBuilder}
     * @param record initial record payload (optional)
     * @returns a builder instance
     */
    init(record) {
        const builder = new create_record_builder_1.CreateRecordBuilder(async (record, reqOptions) => {
            return this.createRecord(this.buildBasePath(), CircleSignerResponse, record, reqOptions);
        });
        record = lodash_1.default.cloneDeep(record);
        return builder.init(record);
    }
    /**
     * Initializes a builder instance that supports chaining to make it
     * easier to work with ledger records. You can pass the record
     * payload to this method to use as initial content, this is useful
     * when you already have an object ready, for example when validating
     * API responses or modifying an existing record. An empty record is
     * going to be created if no initial data is provided.
     *
     * @see {LedgerCircleSigner}
     * @see {DropRecordBuilder}
     * @param id signer identifier (optional)
     * @returns a builder instance
     */
    drop(id) {
        const signerIdentifier = id || this.id;
        const builder = new drop_record_builder_1.DropRecordBuilder(async (record, reqOptions) => {
            return this.dropRecord(`${this.buildBasePath()}/${encodeURIComponent(signerIdentifier)}`, record, reqOptions);
        }, async (reqOptions) => {
            const response = await this.read(signerIdentifier, reqOptions);
            return {
                data: response.circleSigner,
                hash: response.hash,
                luid: response.luid,
                meta: response.meta,
            };
        });
        return builder.init();
    }
    /**
     * Gets a circle signer link by identifier (luid or handle).
     *
     * @see {LedgerCircleSigner}
     * @throws {Error} if the circle signer link doesn't exist or the
     *   current user doesn't have access to this record
     * @param id a unique effect handle
     * @returns a single effect response with the requested effect
     */
    async read(id, options) {
        return this.getRecord(`${this.buildBasePath()}/${encodeURIComponent(id)}`, CircleSignerResponse, options);
    }
    /**
     * Queries signers of a circle from a ledger.
     *
     * @see {LedgerCircleSigner}
     * @param params query parameters
     * @returns signers list response with all found signers
     */
    async list(params) {
        return this.getRecordsList(this.buildBasePath(), CircleSignersResponse, params);
    }
}
exports.CircleSignerClient = CircleSignerClient;
//# sourceMappingURL=circle-signer-client.js.map