import { JwtConfig, LedgerCustom, LedgerHash, LedgerMeta, LedgerRecord, LedgerSigningParams } from "../../../../types/src";
import { RequestOptions } from '../types/request-options';
import { BaseRecordBuilder } from './base-record-builder';
/**
 * Base builder class with a child builder.
 * All the basic operations are delegated to this child builder
 */
export declare abstract class BaseCompositeBuilder<TRecord, TResponse, TMeta extends LedgerMeta = LedgerMeta, TSignData extends LedgerCustom = LedgerCustom> {
    /**
     * Child record builder
     *
     */
    protected recordBuilder: BaseRecordBuilder<TRecord, TMeta>;
    /**
     * Auth params to use for the request to ledger.
     */
    protected authParams: Partial<JwtConfig>;
    constructor(record: Partial<LedgerRecord<TRecord, TMeta>>);
    /**
     * Sets authentication params to the current record.
     * These parameters are stored in memory until the function
     * `send()` is called, when it's used to compose the JWT
     * token sent to Ledger API.
     *
     * @param params the parameters to be assigned to the current auth params object
     * @returns this builder instance for chaining
     */
    auth(params: Partial<JwtConfig>): this;
    /**
     * Returns the current record.
     *
     * NOTE: Reference is directly returned without any cloning,
     * be careful when continuing to use this builder after
     * calling this function. The internal record value could be
     * mutated by mutating the returned value. It is recommended
     * to clone the value in such cases.
     *
     * @returns the current record
     */
    read(): Promise<LedgerRecord<TRecord, TMeta>>;
    /**
     * Sets a hash to the current record, if the hash value is
     * provided. If the value is not provided or falsy calculates
     * a hash of the current version and stores the calculated
     * value in the `hash` property of the record.
     *
     * @param hash the hash to set, or a falsy value to calculate a new hash
     * @returns this builder instance for chaining
     */
    hash(hash?: LedgerHash): this;
    /**
     * Signs the current value of the record's hash with
     * all of the provided key pairs and stores the generated
     * signatures in the `meta.proofs` property of the record.
     *
     * @param params signing parameters to use
     * @returns this builder instance for chaining
     */
    sign(params: LedgerSigningParams<TSignData>[]): this;
    /**
     * Sends the request to the ledger.
     *
     * @param requestOptions Optional request options to use for this request
     * @returns api response with the updated intent
     * @throws if any method in builder chain fails
     */
    abstract send(requestOptions?: RequestOptions): Promise<TResponse>;
}
