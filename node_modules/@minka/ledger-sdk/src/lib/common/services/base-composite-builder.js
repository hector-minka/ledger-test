"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseCompositeBuilder = void 0;
/**
 * @module RecordBuilder / SignIntentBuilder
 * @category Record Builders
 */
const lodash_1 = __importDefault(require("lodash"));
const base_record_builder_1 = require("./base-record-builder");
/**
 * Base builder class with a child builder.
 * All the basic operations are delegated to this child builder
 */
class BaseCompositeBuilder {
    /**
     * Child record builder
     *
     */
    recordBuilder;
    /**
     * Auth params to use for the request to ledger.
     */
    authParams = {};
    constructor(record) {
        this.recordBuilder = new base_record_builder_1.BaseRecordBuilder();
        this.recordBuilder.init(record);
        this.authParams = {};
    }
    /**
     * Sets authentication params to the current record.
     * These parameters are stored in memory until the function
     * `send()` is called, when it's used to compose the JWT
     * token sent to Ledger API.
     *
     * @param params the parameters to be assigned to the current auth params object
     * @returns this builder instance for chaining
     */
    auth(params) {
        const clonedParams = lodash_1.default.cloneDeep(params);
        if (!this.authParams) {
            this.authParams = clonedParams;
        }
        Object.assign(this.authParams, clonedParams);
        return this;
    }
    /**
     * Returns the current record.
     *
     * NOTE: Reference is directly returned without any cloning,
     * be careful when continuing to use this builder after
     * calling this function. The internal record value could be
     * mutated by mutating the returned value. It is recommended
     * to clone the value in such cases.
     *
     * @returns the current record
     */
    async read() {
        return this.recordBuilder.read();
    }
    /**
     * Sets a hash to the current record, if the hash value is
     * provided. If the value is not provided or falsy calculates
     * a hash of the current version and stores the calculated
     * value in the `hash` property of the record.
     *
     * @param hash the hash to set, or a falsy value to calculate a new hash
     * @returns this builder instance for chaining
     */
    hash(hash) {
        this.recordBuilder.hash(hash);
        return this;
    }
    /**
     * Signs the current value of the record's hash with
     * all of the provided key pairs and stores the generated
     * signatures in the `meta.proofs` property of the record.
     *
     * @param params signing parameters to use
     * @returns this builder instance for chaining
     */
    sign(params) {
        this.recordBuilder.sign(params);
        return this;
    }
}
exports.BaseCompositeBuilder = BaseCompositeBuilder;
//# sourceMappingURL=base-composite-builder.js.map