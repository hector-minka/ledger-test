"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseRecordBuilder = void 0;
/**
 * @module RecordBuilder / BaseRecordBuilder
 * @category Record Builders
 */
const lodash_1 = __importDefault(require("lodash"));
const crypto_1 = require("../../../../crypto/src");
const format_1 = require("../../../../format/src");
const ledger_sdk_error_1 = require("../types/ledger-sdk-error");
/**
 * Implements a builder pattern that allows a more
 * convenient way to work with ledger records. This
 * class has functions that simplify construction,
 * hashing, signing, testing and sending records to
 * remote ledger instances.
 *
 * This is a base class that contains generic
 * functionalities that can be reused for various
 * record types.
 *
 * NOTE: current record instance is mutated by this
 * class, we are not cloning instances intentionally,
 * and it isn't advised to reuse builder instances when
 * working with multiple records or mutating objects
 * passed to this builder in external code. It is
 * recommended to clone objects in such cases to avoid
 * unexpected behaviors.
 */
class BaseRecordBuilder {
    /**
     * Auth params to use for the request to ledger.
     */
    authParams;
    /**
     * A ledger record that this instance is operating on.
     *
     * NOTE: this instance is going to be mutated.
     */
    record;
    /**
     * Promise which represents completion all pending async operations.
     */
    pendingAsyncOperations;
    /**
     * Enqueues async operation in builder as a function which is executed
     * when previous async operations are completed.
     *
     * @param operation async operation function
     */
    enqueueAsyncOperation(operation) {
        // There are 2 requirements for builder, first is that we want to have
        // sync functions so we can chain calls like `ledger.signer.init().hash().sign()`
        // and other is that some of these functions perform async operations. For example
        // `sign()` performs async operation because of using async crypto function under
        // the hood and also `init()` performs async operation in extended class
        // `SignerRecordBuilder` because it will use async function from crypto to
        // initialize key pair by default if key pair is not specified.
        // So async operations are used for all builder chainable functions to support
        // future cases where async operations will be required under the hood. Pattern is
        // that chainable public functions such as `data`, `meta`, `hash`,  `sign` are
        // synchronous, but they actually will enqueue async operation by using
        // `this.enqueueAsyncOperation()` wrapper for logic in the function which modify
        // record data. Async operations are executed in sequence in order to have guarantee
        // that all side effects of previous calls are executed before next call is executed.
        //  With that in mind, even if operation is not async in nature, it will better
        // compose with other operations if every operation is wrapped as async and queued.
        if (!this.pendingAsyncOperations) {
            this.pendingAsyncOperations = operation();
        }
        else {
            // This is required in order to chain promises, because we have cases
            // where one async operation depends on results of another.
            // See:
            // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then#return_value
            this.pendingAsyncOperations = this.pendingAsyncOperations.then(() => operation());
        }
    }
    /**
     * Ensures that all async operations in builder are finished.
     *
     * @returns When all async operations in builder are finished
     */
    async finishAsyncOperations() {
        if (!this.pendingAsyncOperations) {
            return;
        }
        await this.pendingAsyncOperations;
    }
    /**
     * Initializes the record. This function will completely
     * replace all existing record properties.
     *
     * @param record the record
     * @returns this builder instance for chaining
     */
    init(record) {
        record = lodash_1.default.cloneDeep(record);
        this.enqueueAsyncOperation(async () => {
            // Initialize record properties to default, if they are not received
            this.record = {
                hash: record?.hash || '',
                luid: record?.luid || undefined,
                data: record?.data || {},
                meta: record?.meta ||
                    {
                        proofs: [],
                    },
            };
            if (!this.record.meta.proofs) {
                this.record.meta.proofs = [];
            }
        });
        return this;
    }
    /**
     * Sets the record data. This function will merge the provided
     * values with any existing properties already present in the
     * record by calling `Object.assign`, i.e., the values aren't going
     * to be merged recursively, only the top level properties will
     * be merged.
     *
     * @see Object.assign
     * @param data the data properties to assign
     * @returns this builder instance for chaining
     */
    data(data) {
        data = lodash_1.default.cloneDeep(data);
        this.enqueueAsyncOperation(async () => {
            Object.assign(this.record.data, data);
        });
        return this;
    }
    /**
     * Sets the record meta. This function will merge the provided
     * values with any existing properties already present in the
     * record by calling `Object.assign`, i.e., the values aren't going
     * to be merged recursively, only the top level properties will
     * be merged.
     *
     * @see Object.assign
     * @param meta the meta properties to assign
     * @returns this builder instance for chaining
     */
    meta(meta) {
        meta = lodash_1.default.cloneDeep(meta);
        this.enqueueAsyncOperation(async () => {
            Object.assign(this.record.meta, meta);
        });
        return this;
    }
    /**
     * Sets a hash to the current record, if the hash value is
     * provided. If the value is not provided or falsy calculates
     * a hash of the current version and stores the calculated
     * value in the `hash` property of the record.
     *
     * @param hash the hash to set, or a falsy value to calculate a new hash
     * @returns this builder instance for chaining
     */
    hash(hash) {
        this.enqueueAsyncOperation(async () => {
            if (hash) {
                this.record.hash = hash;
            }
            else {
                this.record.hash = (0, crypto_1.createHash)(this.record.data);
            }
        });
        return this;
    }
    /**
     * Sets authentication params to the current record.
     * These parameters are stored in memory until the function
     * `send()` is called, when it's used to compose the JWT
     * token sent to Ledger API.
     *
     * @param params the parameters to be assigned to the current auth params object
     * @returns this builder instance for chaining
     */
    auth(params) {
        params = lodash_1.default.cloneDeep(params);
        this.enqueueAsyncOperation(async () => {
            Object.assign(this.authParams, params);
        });
        return this;
    }
    /**
     * Signs the current value of the record's hash with
     * all of the provided key pairs and stores the generated
     * signatures in the `meta.proofs` property of the record.
     *
     * @param params signing params to use
     * @returns this builder instance for chaining
     */
    sign(params) {
        this.enqueueAsyncOperation(async () => {
            const hash = this.record.hash;
            if (!hash) {
                throw new Error(`Invalid record hash, set a hash by calling '.hash()' ` +
                    `before attempting to sign a record.`);
            }
            for (const p of params) {
                // Add moment just in case it's not provided
                const custom = {
                    moment: (0, format_1.formatDate)(),
                    ...p.custom,
                };
                const signature = await (0, crypto_1.signHash)(hash, p.keyPair, custom);
                this.record.meta.proofs.push(signature);
            }
        });
        return this;
    }
    /**
     * Returns the current state of constructed record.
     *
     * NOTE: Reference is directly returned without any cloning,
     * be careful when continuing to use this builder after
     * calling this function. The internal record value could be
     * mutated by mutating the returned value. It is recommended
     * to clone the value in such cases.
     *
     * @returns the current state of constructed record
     */
    async read() {
        try {
            await this.finishAsyncOperations();
            return this.record;
        }
        catch (error) {
            throw new ledger_sdk_error_1.LedgerSdkError(error);
        }
    }
}
exports.BaseRecordBuilder = BaseRecordBuilder;
//# sourceMappingURL=base-record-builder.js.map