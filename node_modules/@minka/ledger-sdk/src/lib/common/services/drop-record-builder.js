"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DropRecordBuilder = void 0;
const lodash_1 = require("lodash");
const fp_1 = __importDefault(require("lodash/fp"));
const types_1 = require("../../../../types/src");
const ledger_sdk_error_1 = require("../types/ledger-sdk-error");
const base_record_builder_1 = require("./base-record-builder");
/**
 * Implements a builder pattern that allows a more
 * convenient way to work with ledger records. This
 * class has functions that simplify construction,
 * hashing, signing, testing and sending records to
 * remote ledger instances.
 *
 * This builder is intended for record drops, sending
 * a record to ledger will perform the drop operation
 * on the API with the record that was prepared in the
 * builder.
 *
 * NOTE: current record instance is mutated by this
 * class, we are not cloning instances intentionally,
 * and it isn't advised to reuse builder instances when
 * working with multiple records or mutating objects
 * passed to this builder in external code. It is
 * recommended to clone objects in such cases to avoid
 * unexpected behaviors.
 */
class DropRecordBuilder extends base_record_builder_1.BaseRecordBuilder {
    /**
     * A handler for droping records on the remote API.
     */
    dropRecord;
    /**
     * A handler for reading records on the remote API.
     */
    readRecord;
    /**
     * Creates new instance of record builder.
     *
     * @param dropRecord function which drops records on ledger API.
     */
    constructor(dropRecord, readRecord) {
        super();
        this.dropRecord = dropRecord;
        this.readRecord = readRecord;
    }
    /**
     * Initializes the record. This function will completely
     * replace all existing record properties.
     *
     * @param record the record
     * @returns this builder instance for chaining
     */
    init() {
        this.enqueueAsyncOperation(async () => {
            const record = await this.readRecord({ authParams: this.authParams });
            const recordClone = (0, lodash_1.cloneDeep)(record);
            // Clear all existing signatures, since they should be
            // set again by the user
            (0, lodash_1.set)(recordClone, 'meta.proofs', []);
            (0, lodash_1.set)(recordClone, 'meta.moment', undefined);
            (0, lodash_1.set)(recordClone, 'hash', undefined);
            (0, lodash_1.set)(recordClone, 'data', { parent: record.hash });
            this.record = recordClone;
        });
        return this;
    }
    /**
     * Sends the current record version to the remote ledger.
     *
     * @param requestOptions Optional request options to use for this request
     * @returns api response with the dropped record
     * @throws if any method in builder chain fails
     */
    async send(requestOptions) {
        try {
            await this.finishAsyncOperations();
            const finalOptions = {
                authParams: requestOptions?.authParams ?? this.authParams,
                headers: requestOptions?.headers,
            };
            return this.dropRecord(this.record, finalOptions);
        }
        catch (error) {
            throw new ledger_sdk_error_1.LedgerSdkError(error);
        }
    }
    /**
     * Sets custom.status 'dropped' to all the signatures.
     *
     * @param params signatures
     * @returns this builder instance for chaining
     */
    sign(params) {
        const flow = fp_1.default.flow([
            fp_1.default.cloneDeep,
            fp_1.default.set('custom.status', types_1.LedgerSignatureStatus.Dropped),
        ]);
        params = fp_1.default.map(flow)(params);
        return super.sign(params);
    }
}
exports.DropRecordBuilder = DropRecordBuilder;
//# sourceMappingURL=drop-record-builder.js.map