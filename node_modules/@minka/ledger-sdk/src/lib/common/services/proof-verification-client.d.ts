import { LedgerProof, LedgerPublic, LedgerRecord } from "../../../../types/src";
import { LedgerSdkError } from '../types/ledger-sdk-error';
import type { PartialDeep } from 'type-fest';
type ComparableSignature = PartialDeep<LedgerProof>;
export declare class ProofVerificationClient {
    private ledgerSigner;
    private assertions;
    /**
     *
     * @param signer ledger signer, used to
     * verify responses sent by the ledger.
     */
    constructor(signer: LedgerPublic);
    protected assertLength(record: LedgerRecord<any>, min: number, max?: number): void;
    protected assertExpect(record: LedgerRecord<any>, match: ComparableSignature): void;
    protected assert(record: LedgerRecord<any>): void;
    /**
     *
     * @param record the ledger record to verify
     * @throws {LedgerSdkError} if the record has invalid proofs
     * or if the record does not match the assertions
     * @returns Promise<void>
     */
    verify(record: LedgerRecord<any>): Promise<void>;
    /**
     * Return the chain of errors for
     * a ledger record is given.
     * Errors are detected, extracted from
     * record proofs list based on 'reason' field and
     * they are sorted by timestamp on which the newest
     * error is returned while others are linked through
     * causedBy chain.
     *
     * @param record the ledger record to get errors
     * @returns LedgerSdkError with chained errors
     */
    error(record: LedgerRecord<any>): LedgerSdkError;
    /**
     * Expect the record to have at least one signature matching the given
     * partial signature.
     * @param matcher a partial signature to match
     * @returns this the chainable signature verification client
     */
    expect(matcher: ComparableSignature | ComparableSignature[]): this;
    /**
     * Expect the record to be signed by the ledger signer
     * @returns this the chainable signature verification client
     */
    ledger(): this;
    /**
     * Expect the record to have between min and max proofs
     * If not max is provided, only min is asserted.
     * @param min minimum number of proofs
     * @param max maximum number of proofs. Optional.
     * @returns this the chainable signature verification client
     */
    length(min: number, max?: number): this;
}
export {};
