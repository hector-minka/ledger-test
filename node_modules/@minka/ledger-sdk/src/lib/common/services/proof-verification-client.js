"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProofVerificationClient = void 0;
/**
 * @module Services / ProofVerificationClient
 * @category Services
 */
const lodash_1 = __importDefault(require("lodash"));
const crypto_1 = require("../../../../crypto/src");
const errors_1 = require("../../../../errors/src");
const errors_2 = require("../../../../errors/src");
const ledger_sdk_error_1 = require("../types/ledger-sdk-error");
class ProofVerificationClient {
    ledgerSigner;
    assertions = [];
    /**
     *
     * @param signer ledger signer, used to
     * verify responses sent by the ledger.
     */
    constructor(signer) {
        this.ledgerSigner = signer;
        this.length(1);
    }
    assertLength(record, min, max) {
        if (record.meta.proofs.length < min) {
            throw new errors_2.CryptoSignatureMissing(`Expected at least ${min} proofs, got ${record.meta.proofs.length}.`);
        }
        if (max && record.meta.proofs.length > max) {
            throw new errors_2.CryptoSignatureMissing(`Expected at most ${max} proofs, got ${record.meta.proofs.length}.`);
        }
    }
    assertExpect(record, match) {
        if (!lodash_1.default.some(record.meta.proofs, match)) {
            throw new errors_2.CryptoSignatureMissing(`Expected signature not found.`);
        }
    }
    assert(record) {
        for (const assertion of this.assertions) {
            if (assertion.type === 'length') {
                this.assertLength(record, assertion.min, assertion.max);
            }
            if (assertion.type === 'expect') {
                for (const matcher of assertion.match) {
                    this.assertExpect(record, matcher);
                }
            }
        }
    }
    /**
     *
     * @param record the ledger record to verify
     * @throws {LedgerSdkError} if the record has invalid proofs
     * or if the record does not match the assertions
     * @returns Promise<void>
     */
    async verify(record) {
        if (!record?.meta?.proofs) {
            throw new errors_2.CryptoSignatureMissing('This record has no proofs.');
        }
        if (!record?.hash) {
            throw new errors_2.CryptoHashInvalid('This record has no hash.');
        }
        try {
            for (const signature of record.meta.proofs) {
                const isValid = await (0, crypto_1.verifySignature)(record.hash, signature);
                if (!isValid) {
                    throw new errors_2.CryptoSignatureInvalid('This record has one or more invalid proofs.');
                }
            }
            this.assert(record);
        }
        catch (error) {
            throw new ledger_sdk_error_1.LedgerSdkError(error);
        }
    }
    /**
     * Return the chain of errors for
     * a ledger record is given.
     * Errors are detected, extracted from
     * record proofs list based on 'reason' field and
     * they are sorted by timestamp on which the newest
     * error is returned while others are linked through
     * causedBy chain.
     *
     * @param record the ledger record to get errors
     * @returns LedgerSdkError with chained errors
     */
    error(record) {
        if (!record.meta || !Array.isArray(record.meta.proofs)) {
            return;
        }
        const errorProofs = lodash_1.default.orderBy((0, lodash_1.default)(record)
            .get('meta.proofs')
            .filter((proof) => proof.custom?.reason), 'custom.moment', 'desc');
        const getError = (errorProof, causedBy) => {
            return new errors_1.LedgerError(errorProof.custom?.reason, errorProof.custom?.detail, {
                causedBy,
            });
        };
        let latestErrorProof = errorProofs.pop();
        let error;
        while (latestErrorProof) {
            error = getError(latestErrorProof, error);
            latestErrorProof = errorProofs.pop();
        }
        if (error) {
            return new ledger_sdk_error_1.LedgerSdkError(error);
        }
    }
    /**
     * Expect the record to have at least one signature matching the given
     * partial signature.
     * @param matcher a partial signature to match
     * @returns this the chainable signature verification client
     */
    expect(matcher) {
        matcher = lodash_1.default.isArray(matcher) ? matcher : [matcher];
        this.assertions.push({
            type: 'expect',
            match: matcher,
        });
        return this;
    }
    /**
     * Expect the record to be signed by the ledger signer
     * @returns this the chainable signature verification client
     */
    ledger() {
        /**
         * For now, this value is hardcoded because mapping
         * from `signer.format` to `signature.method` is not
         * defined nor implemented.
         */
        const matcher = {
            public: this.ledgerSigner.public,
            method: 'ed25519-v2',
        };
        this.expect(matcher);
        return this;
    }
    /**
     * Expect the record to have between min and max proofs
     * If not max is provided, only min is asserted.
     * @param min minimum number of proofs
     * @param max maximum number of proofs. Optional.
     * @returns this the chainable signature verification client
     */
    length(min, max) {
        this.assertions.push({
            type: 'length',
            min,
            max,
        });
        return this;
    }
}
exports.ProofVerificationClient = ProofVerificationClient;
//# sourceMappingURL=proof-verification-client.js.map