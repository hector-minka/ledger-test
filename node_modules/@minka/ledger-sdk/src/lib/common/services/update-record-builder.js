"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UpdateRecordBuilder = exports.linkToParent = void 0;
/**
 * @module RecordBuilder / UpdateRecordBuilder
 * @category Record Builders
 */
const lodash_1 = require("lodash");
const ledger_sdk_error_1 = require("../types/ledger-sdk-error");
const base_record_builder_1 = require("./base-record-builder");
/**
 * Links current hash to parent and removes hash.
 *
 * @param record record to modify
 */
const linkToParent = (record) => {
    (0, lodash_1.set)(record, 'data.parent', record.hash);
    (0, lodash_1.set)(record, 'hash', undefined);
};
exports.linkToParent = linkToParent;
/**
 * Implements a builder pattern that allows a more
 * convenient way to work with ledger records. This
 * class has functions that simplify construction,
 * hashing, signing, testing and sending records to
 * remote ledger instances.
 *
 * This builder is intended for record updates, sending
 * a record to ledger will perform the update operation
 * on the API with the record that was prepared in the
 * builder.
 *
 * NOTE: current record instance is mutated by this
 * class, we are not cloning instances intentionally,
 * and it isn't advised to reuse builder instances when
 * working with multiple records or mutating objects
 * passed to this builder in external code. It is
 * recommended to clone objects in such cases to avoid
 * unexpected behaviors.
 */
class UpdateRecordBuilder extends base_record_builder_1.BaseRecordBuilder {
    /**
     * A handler for updating records on the remote API.
     */
    updateRecord;
    /**
     * A handler for adding proofs to records on the remote API.
     */
    addProof;
    /**
     * Defines if the builder should update
     * the record or just add a proof
     */
    isUpdate;
    /**
     * Parent hash
     */
    parent;
    /**
     * Creates new instance of record builder.
     * The target action - send - will change according
     * to isUpdate flag state. If isUpdate is true, the method
     * send() will call `updateRecord` function. Otherwise,
     * it will execute `addProof`.
     *
     * @param updateRecord function which updates records on ledger API.
     * @param addProof function which adds proofs to records on ledger API
     */
    constructor(updateRecord, addProof) {
        super();
        this.updateRecord = updateRecord;
        this.addProof = addProof;
    }
    /**
     * Initializes the record. This function will completely
     * replace all existing record properties when record
     * moment is parent.
     *
     * @param record the record
     * @returns this builder instance for chaining
     */
    init(record) {
        this.isUpdate = false;
        const recordClone = (0, lodash_1.cloneDeep)(record);
        // Clear all existing signatures, since they are invalid
        // in case of any changes.
        (0, lodash_1.set)(recordClone, 'meta.proofs', []);
        // Clear other data from meta that are not
        // taken into account when updating a record
        (0, lodash_1.set)(recordClone, 'meta.status', undefined);
        (0, lodash_1.set)(recordClone, 'meta.owners', undefined);
        (0, lodash_1.set)(recordClone, 'meta.moment', undefined);
        (0, lodash_1.set)(recordClone, 'meta.luid', undefined);
        super.init(recordClone);
        return this;
    }
    /**
     * Sets the record data. This function will merge the input with
     * the existing record. If you want to completely replace the existing
     * data, pass the second argument as true.
     * You can pass null as the value of any property to remove it from
     * the record.
     *
     * @see Object.assign
     * @param data the data properties to assign
     * @param replace flag that indicates if the record data
     *                i.e. `this.record.data` should be replaced(true) or
     *                merged(false)
     * @returns this builder instance for chaining
     */
    data(data, replace = false) {
        data = (0, lodash_1.cloneDeep)(data);
        this.isUpdate = true;
        this.enqueueAsyncOperation(async () => {
            const parent = this.parent;
            if (replace) {
                (0, lodash_1.set)(this.record, 'data', data);
            }
            else {
                let newData = (0, lodash_1.cloneDeep)(this.record.data);
                /**
                 * Here we use lodash.merge instead of Object.assign so we
                 * can merge nested objects. This is useful for updating
                 * single nested properties without affecting it siblings.
                 */
                newData = (0, lodash_1.merge)(newData, data);
                newData = this.deepRemoveNull(newData);
                (0, lodash_1.set)(this.record, 'data', newData);
            }
            if (this.record.hash && !parent) {
                (0, exports.linkToParent)(this.record);
                this.parent = this.record.data.parent;
            }
            /**
             * Keep record parent.
             * Parent is set with base record's hash value
             * when initiliazing it via `from()` chainning
             * method to improve user's experience.
             */
            if (parent) {
                (0, lodash_1.set)(this.record, 'data.parent', parent);
            }
        });
        return this;
    }
    /**
     * This function is used to remove the null and empty entries after
     * merging the data. Useful for removing properties that wouldn't be
     * saved on database from the record and generate a proper signature.
     * @param object Object to remove null entries from
     * @returns Object with null entries removed
     */
    deepRemoveNull(object) {
        if (!(0, lodash_1.isObject)(object))
            return object;
        const wasArray = (0, lodash_1.isArray)(object);
        const clear = Object.entries(object)
            .filter(([, value]) => (0, lodash_1.isNil)(value) === false)
            .reduce((r, [key, value]) => ({ ...r, [key]: this.deepRemoveNull(value) }), {});
        return wasArray ? Object.values(clear) : clear;
    }
    /**
     * Sends the current record version to the remote ledger.
     *
     * @param requestOptions optional request options
     * @returns api response with the updated record
     * @throws if any method in builder chain fails
     */
    async send(requestOptions) {
        try {
            await this.finishAsyncOperations();
            const finalOptions = {
                authParams: requestOptions?.authParams ?? this.authParams,
                headers: requestOptions?.headers,
            };
            if (this.isUpdate) {
                return this.updateRecord(this.record, finalOptions);
            }
            const proofs = this.record?.meta?.proofs || [];
            if (proofs.length === 0) {
                throw new Error('Unable to send proofs, no proofs found!');
            }
            let result = null;
            for (const proof of proofs) {
                result = await this.addProof(proof, finalOptions);
            }
            return result;
        }
        catch (error) {
            throw new ledger_sdk_error_1.LedgerSdkError(error);
        }
    }
}
exports.UpdateRecordBuilder = UpdateRecordBuilder;
//# sourceMappingURL=update-record-builder.js.map