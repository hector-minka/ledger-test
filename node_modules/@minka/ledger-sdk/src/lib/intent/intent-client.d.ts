/**
 * @module Clients / Intents
 * @category Entities
 */
import { AxiosResponse } from 'axios';
import { IntentMeta, IntentRecord, LedgerIdentifier, LedgerIntent, LedgerPagedList } from "../../../types/src";
import { AccessClient } from '../common/clients/access-client';
import { BaseChangeClient } from '../common/clients/base-change-client';
import { BaseClient, BaseClientOptions } from '../common/clients/base-client';
import { CreateRecordBuilder } from '../common/services/create-record-builder';
import { BaseRecordResponse } from '../common/types/base-record-response';
import { BaseListResponse } from '../common/types/list-response';
import { BaseReadOptions } from '../common/types/read-options';
import { IntentListParams } from './intent-list-params';
import { SignIntentBuilder } from './sign-intent-builder';
/**
 * Single intent API response.
 * @private
 */
export declare class IntentResponse extends BaseRecordResponse<LedgerIntent, IntentMeta> {
    /**
     * Record data extracted from the `data` property of the response body.
     */
    intent: LedgerIntent;
    constructor(response: AxiosResponse<IntentRecord, IntentRecord>);
}
/**
 * Intents list API response.
 * @private
 */
export declare class IntentsResponse extends BaseListResponse<LedgerIntent, IntentMeta> {
    /**
     * A flattened list of records, extracted from the `data` property of
     * each record returned.
     */
    intents: LedgerIntent[];
    constructor(response: AxiosResponse<LedgerPagedList<LedgerIntent, IntentMeta>, void>);
}
/**
 * Allows querying and managing intents.
 * @see {LedgerIntent}
 */
export declare class IntentClient extends BaseClient {
    /**
     * Allows querying changes.
     *
     */
    change: BaseChangeClient<LedgerIntent>;
    /**
     * Allows checking access.
     *
     */
    access: AccessClient;
    constructor(options: BaseClientOptions);
    /**
     * Initializes a builder instance intended for creating records which
     * supports chaining to make it easier to work with ledger records. You
     * can pass the record payload to this method to use as initial content,
     * this is useful when you already have an object ready, for example when
     * validating API responses or modifying an existing record. An empty
     * record is going to be created if no initial data is provided.
     *
     * @see {LedgerIntent}
     * @see {CreateRecordBuilder}
     * @param record initial record payload (optional)
     * @returns {CreateRecordBuilder} a builder instance
     */
    init(record?: Partial<IntentRecord>): CreateRecordBuilder<LedgerIntent, IntentResponse, IntentMeta>;
    /**
     * Initializes a builder instance intended for adding intent signatures which
     * supports chaining to make it easier to work with ledger records. This method
     * expects an existing intent that is already stored in a ledger as argument.
     *
     * @see {LedgerIntent}
     * @see {SignIntentBuilder}
     * @param record Initializes a builder from the provided data
     * @returns a builder instance
     */
    from(record: IntentRecord): SignIntentBuilder;
    /**
     * Gets a ledger intent by identifier (luid or handle).
     *
     * @see {LedgerIntent}
     * @throws {Error} if the intent doesn't exist or the
     *   current user doesn't have access to this intent
     * @param id an unique intent identifier
     * @returns a single intent response with the requested intent
     */
    read(id: LedgerIdentifier, options?: BaseReadOptions): Promise<IntentResponse>;
    /**
     * Queries intents from a ledger that the current
     * user has access to.
     *
     * @see {LedgerIntent}
     * @param params query parameters
     * @returns intents list response with all found intents
     */
    list(params?: IntentListParams): Promise<IntentsResponse>;
}
