"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.IntentClient = exports.IntentsResponse = exports.IntentResponse = void 0;
const lodash_1 = __importDefault(require("lodash"));
const access_client_1 = require("../common/clients/access-client");
const base_change_client_1 = require("../common/clients/base-change-client");
const base_client_1 = require("../common/clients/base-client");
const create_record_builder_1 = require("../common/services/create-record-builder");
const base_record_response_1 = require("../common/types/base-record-response");
const list_response_1 = require("../common/types/list-response");
const sign_intent_builder_1 = require("./sign-intent-builder");
const INTENTS_PATH = '/intents';
/**
 * Single intent API response.
 * @private
 */
class IntentResponse extends base_record_response_1.BaseRecordResponse {
    /**
     * Record data extracted from the `data` property of the response body.
     */
    intent;
    constructor(response) {
        super(response);
        this.intent = response?.data?.data;
    }
}
exports.IntentResponse = IntentResponse;
/**
 * Intents list API response.
 * @private
 */
class IntentsResponse extends list_response_1.BaseListResponse {
    /**
     * A flattened list of records, extracted from the `data` property of
     * each record returned.
     */
    intents;
    constructor(response) {
        super(response);
        this.intents = response?.data?.data?.map((record) => record.data);
    }
}
exports.IntentsResponse = IntentsResponse;
/**
 * Allows querying and managing intents.
 * @see {LedgerIntent}
 */
class IntentClient extends base_client_1.BaseClient {
    /**
     * Allows querying changes.
     *
     */
    change;
    /**
     * Allows checking access.
     *
     */
    access;
    constructor(options) {
        super(options);
        this.change = new base_change_client_1.BaseChangeClient(options, INTENTS_PATH);
        this.access = new access_client_1.AccessClient(options, INTENTS_PATH);
        this.links = [this.change, this.access];
    }
    /**
     * Initializes a builder instance intended for creating records which
     * supports chaining to make it easier to work with ledger records. You
     * can pass the record payload to this method to use as initial content,
     * this is useful when you already have an object ready, for example when
     * validating API responses or modifying an existing record. An empty
     * record is going to be created if no initial data is provided.
     *
     * @see {LedgerIntent}
     * @see {CreateRecordBuilder}
     * @param record initial record payload (optional)
     * @returns {CreateRecordBuilder} a builder instance
     */
    init(record) {
        const builder = new create_record_builder_1.CreateRecordBuilder(async (record, reqOptions) => {
            return this.createRecord(INTENTS_PATH, IntentResponse, record, reqOptions);
        });
        record = lodash_1.default.cloneDeep(record);
        return builder.init(record);
    }
    /**
     * Initializes a builder instance intended for adding intent signatures which
     * supports chaining to make it easier to work with ledger records. This method
     * expects an existing intent that is already stored in a ledger as argument.
     *
     * @see {LedgerIntent}
     * @see {SignIntentBuilder}
     * @param record Initializes a builder from the provided data
     * @returns a builder instance
     */
    from(record) {
        record = lodash_1.default.cloneDeep(record);
        return new sign_intent_builder_1.SignIntentBuilder(async (signature, reqOptions) => {
            return this.signRecord(`${INTENTS_PATH}/${encodeURIComponent(record.data.handle)}/proofs`, IntentResponse, signature, reqOptions);
        }, record);
    }
    /**
     * Gets a ledger intent by identifier (luid or handle).
     *
     * @see {LedgerIntent}
     * @throws {Error} if the intent doesn't exist or the
     *   current user doesn't have access to this intent
     * @param id an unique intent identifier
     * @returns a single intent response with the requested intent
     */
    async read(id, options) {
        return this.getRecord(`${INTENTS_PATH}/${encodeURIComponent(id)}`, IntentResponse, options);
    }
    /**
     * Queries intents from a ledger that the current
     * user has access to.
     *
     * @see {LedgerIntent}
     * @param params query parameters
     * @returns intents list response with all found intents
     */
    async list(params) {
        return this.getRecordsList(INTENTS_PATH, IntentsResponse, params);
    }
}
exports.IntentClient = IntentClient;
//# sourceMappingURL=intent-client.js.map