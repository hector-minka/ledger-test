/**
 * @module RecordBuilder / SignIntentBuilder
 * @category Record Builders
 */
import { IntentMeta, IntentProofCustom, IntentRecord, LedgerIntent, LedgerProof } from "../../../types/src";
import { BaseCompositeBuilder } from '../common/services/base-composite-builder';
import { RequestOptions } from '../common/types/request-options';
import { IntentResponse } from './intent-client';
type SendSignatureFunction = (signature: LedgerProof<IntentProofCustom>, reqOptions?: RequestOptions) => Promise<IntentResponse>;
/**
 * Specific builder for adding signatures to ledger intents.
 * Intent content cannot be modified, the only updates allowed
 * on intents are adding signatures which are used to control
 * intent processing.
 *
 * @example
 * // Adding a new signature to an existing intent
 * const { intent } = await sdk.intent
 *  .from(ledgerIntent)
 *  .hash()
 *  .sign([{
 *     keyPair: {
 *       format: keyPair.format,
 *       public: keyPair.public,
 *       secret: keyPair.secret,
 *     },
 *     custom: {
 *       someKey: 'someValue'
 *     }
 *   }])
 *  .send()
 */
export declare class SignIntentBuilder extends BaseCompositeBuilder<LedgerIntent, IntentResponse, IntentMeta, IntentProofCustom> {
    /**
     * A handler function used to submit a signature to ledger.
     */
    private sendSignature;
    /**
     * New signatures start index. Only signatures from this
     * index are going to be sent to ledger. Earlier signatures
     * existed on the record before it was passed to this builder.
     */
    private newSignaturesStartIndex;
    constructor(sendSignature: SendSignatureFunction, intent: IntentRecord);
    /**
     * Sends the new signatures to ledger.
     *
     * @param requestOptions Optional request options to use for this request
     * @returns api response with the updated intent
     * @throws if any method in builder chain fails
     */
    send(requestOptions?: RequestOptions): Promise<IntentResponse>;
}
export {};
