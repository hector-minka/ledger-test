import { AxiosResponse } from 'axios';
import { JwtConfig, LedgerHandle, LedgerIdentifier, LedgerPagedList, LedgerReport, ReportMeta, ReportRecord } from "../../../types/src";
import { AccessClient } from '../common/clients/access-client';
import { BaseChangeClient } from '../common/clients/base-change-client';
import { BaseClient, BaseClientOptions } from '../common/clients/base-client';
import { CreateRecordBuilder } from '../common/services/create-record-builder';
import { DropRecordBuilder } from '../common/services/drop-record-builder';
import { BaseRecordResponse } from '../common/types/base-record-response';
import { BaseListResponse } from '../common/types/list-response';
import { BaseReadOptions } from '../common/types/read-options';
import { ReportListParams } from './report-list-params';
import { SignReportBuilder } from './sign-report-builder';
/**
 * Single report API response.
 */
export declare class ReportResponse extends BaseRecordResponse<LedgerReport, ReportMeta> {
    /**
     * Record data extracted from the `data` property of the response body.
     */
    report: LedgerReport;
    constructor(response: AxiosResponse<ReportRecord, ReportRecord>);
}
/**
 * Reports list API response.
 */
export declare class ReportsResponse extends BaseListResponse<LedgerReport, ReportMeta> {
    /**
     * A flattened list of records, extracted from the `data` property of
     * each record returned.
     */
    reports: LedgerReport[];
    constructor(response: AxiosResponse<LedgerPagedList<LedgerReport, ReportMeta>, void>);
}
/**
 * Allows querying and managing reports.
 *
 * @see {LedgerReport}
 */
export declare class ReportClient extends BaseClient {
    /**
     * Allows querying changes.
     *
     */
    change: BaseChangeClient<LedgerReport>;
    /**
     * Allows checking access.
     *
     */
    access: AccessClient;
    constructor(options: BaseClientOptions);
    /**
     * Initializes a builder instance that supports chaining to make it
     * easier to work with ledger records. You can pass the record
     * payload to this method to use as initial content, this is useful
     * when you already have an object ready, for example when validating
     * API responses or modifying an existing record. An empty record is
     * going to be created if no initial data is provided.
     *
     * @see {LedgerReport}
     * @see {CreateRecordBuilder}
     * @param options.record initial record payload (optional)
     * @param options.handle specify handle to be updated, if any (optional)
     * @returns a builder instance
     */
    init(record?: Partial<ReportRecord>): CreateRecordBuilder<LedgerReport, ReportResponse, ReportMeta>;
    /**
     * Initializes a builder instance intended for adding report signatures which
     * supports chaining to make it easier to work with ledger records. This method
     * expects an existing report that is already stored in a ledger as argument.
     *
     * @see {LedgerReport}
     * @see {SignReportBuilder}
     * @param record Initializes a builder from the provided data
     * @returns a builder instance
     */
    from(record: ReportRecord): SignReportBuilder;
    /**
     * Initializes a builder instance that supports chaining to make it
     * easier to work with ledger records. You can pass the record
     * payload to this method to use as initial content, this is useful
     * when you already have an object ready, for example when validating
     * API responses or modifying an existing record. An empty record is
     * going to be created if no initial data is provided.
     *
     * @see {LedgerReport}
     * @see {DropRecordBuilder}
     * @param id report identifier (optional)
     * @returns a builder instance
     */
    drop(id?: LedgerIdentifier): DropRecordBuilder<LedgerReport, import("../../../types/src").LedgerMeta>;
    /**
     * Gets a ledger report by identifier (luid or handle).
     *
     * @see {LedgerReport}
     * @throws {Error} if the report doesn't exist or the
     *   current user doesn't have access to this report
     * @param id a unique report handle
     * @returns a single report response with the requested report
     */
    read(id: LedgerIdentifier, options?: BaseReadOptions): Promise<ReportResponse>;
    private parseFilename;
    /**
     * Queries reports from a ledger.
     *
     * @see {LedgerReport}
     * @returns reports list response with all found reports
     */
    list(params?: ReportListParams): Promise<ReportsResponse>;
    downloadAsset(id: LedgerIdentifier, asset: LedgerHandle, filename?: string, authParams?: Partial<JwtConfig>): Promise<{
        usedFilename: string;
        originalFilename: string;
    }>;
}
