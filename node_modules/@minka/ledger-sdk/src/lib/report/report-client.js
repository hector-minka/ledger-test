"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ReportClient = exports.ReportsResponse = exports.ReportResponse = void 0;
/**
 * @module Clients / Reports
 * @category Entities
 */
const node_fs_1 = require("node:fs");
const stream = __importStar(require("node:stream"));
const util_1 = require("util");
const lodash_1 = __importDefault(require("lodash"));
const access_client_1 = require("../common/clients/access-client");
const base_change_client_1 = require("../common/clients/base-change-client");
const base_client_1 = require("../common/clients/base-client");
const create_record_builder_1 = require("../common/services/create-record-builder");
const drop_record_builder_1 = require("../common/services/drop-record-builder");
const base_record_response_1 = require("../common/types/base-record-response");
const ledger_sdk_error_1 = require("../common/types/ledger-sdk-error");
const list_response_1 = require("../common/types/list-response");
const sign_report_builder_1 = require("./sign-report-builder");
const REPORTS_PATH = '/reports';
const finished = (0, util_1.promisify)(stream.finished);
/**
 * Single report API response.
 */
class ReportResponse extends base_record_response_1.BaseRecordResponse {
    /**
     * Record data extracted from the `data` property of the response body.
     */
    report;
    constructor(response) {
        super(response);
        this.report = response?.data?.data;
    }
}
exports.ReportResponse = ReportResponse;
/**
 * Reports list API response.
 */
class ReportsResponse extends list_response_1.BaseListResponse {
    /**
     * A flattened list of records, extracted from the `data` property of
     * each record returned.
     */
    reports;
    constructor(response) {
        super(response);
        this.reports = response?.data?.data?.map((record) => record.data);
    }
}
exports.ReportsResponse = ReportsResponse;
/**
 * Allows querying and managing reports.
 *
 * @see {LedgerReport}
 */
class ReportClient extends base_client_1.BaseClient {
    /**
     * Allows querying changes.
     *
     */
    change;
    /**
     * Allows checking access.
     *
     */
    access;
    constructor(options) {
        super(options);
        this.change = new base_change_client_1.BaseChangeClient(options, REPORTS_PATH);
        this.access = new access_client_1.AccessClient(options, REPORTS_PATH);
        this.links = [this.change, this.access];
    }
    /**
     * Initializes a builder instance that supports chaining to make it
     * easier to work with ledger records. You can pass the record
     * payload to this method to use as initial content, this is useful
     * when you already have an object ready, for example when validating
     * API responses or modifying an existing record. An empty record is
     * going to be created if no initial data is provided.
     *
     * @see {LedgerReport}
     * @see {CreateRecordBuilder}
     * @param options.record initial record payload (optional)
     * @param options.handle specify handle to be updated, if any (optional)
     * @returns a builder instance
     */
    init(record) {
        const builder = new create_record_builder_1.CreateRecordBuilder(async (record, reqOptions) => {
            return this.createRecord(REPORTS_PATH, ReportResponse, record, reqOptions);
        });
        record = lodash_1.default.cloneDeep(record);
        return builder.init(record);
    }
    /**
     * Initializes a builder instance intended for adding report signatures which
     * supports chaining to make it easier to work with ledger records. This method
     * expects an existing report that is already stored in a ledger as argument.
     *
     * @see {LedgerReport}
     * @see {SignReportBuilder}
     * @param record Initializes a builder from the provided data
     * @returns a builder instance
     */
    from(record) {
        record = lodash_1.default.cloneDeep(record);
        return new sign_report_builder_1.SignReportBuilder(async (signature, reqOptions) => {
            return this.signRecord(`${REPORTS_PATH}/${encodeURIComponent(record.data.handle)}/proofs`, ReportResponse, signature, reqOptions);
        }, record);
    }
    /**
     * Initializes a builder instance that supports chaining to make it
     * easier to work with ledger records. You can pass the record
     * payload to this method to use as initial content, this is useful
     * when you already have an object ready, for example when validating
     * API responses or modifying an existing record. An empty record is
     * going to be created if no initial data is provided.
     *
     * @see {LedgerReport}
     * @see {DropRecordBuilder}
     * @param id report identifier (optional)
     * @returns a builder instance
     */
    drop(id) {
        const reportIdentifier = id || this.id;
        const builder = new drop_record_builder_1.DropRecordBuilder(async (record, reqOptions) => {
            return this.dropRecord(`${REPORTS_PATH}/${encodeURIComponent(reportIdentifier)}`, record, reqOptions);
        }, async (reqOptions) => {
            const response = await this.read(reportIdentifier, reqOptions);
            return {
                data: response.report,
                hash: response.hash,
                luid: response.luid,
                meta: response.meta,
            };
        });
        return builder.init();
    }
    /**
     * Gets a ledger report by identifier (luid or handle).
     *
     * @see {LedgerReport}
     * @throws {Error} if the report doesn't exist or the
     *   current user doesn't have access to this report
     * @param id a unique report handle
     * @returns a single report response with the requested report
     */
    async read(id, options) {
        return this.getRecord(`${REPORTS_PATH}/${encodeURIComponent(id)}`, ReportResponse, options);
    }
    parseFilename(response) {
        const contentDisposition = response.headers['content-disposition'];
        const match = contentDisposition.match(/filename="(?<filename>[^"]+)"/);
        if (!match) {
            throw new Error(`Invalid Content-Disposition: ${contentDisposition}`);
        }
        return match.groups.filename;
    }
    /**
     * Queries reports from a ledger.
     *
     * @see {LedgerReport}
     * @returns reports list response with all found reports
     */
    async list(params) {
        return this.getRecordsList(REPORTS_PATH, ReportsResponse, params);
    }
    async downloadAsset(id, asset, filename, authParams) {
        const path = this.createRelativeUrl(`${REPORTS_PATH}/${encodeURIComponent(id)}/assets/${encodeURIComponent(asset)}`);
        const abortController = new AbortController();
        const abortSignal = abortController.signal;
        try {
            const token = await this.buildJwt({
                method: 'GET',
                url: path,
                body: {},
                protectedHeaders: [],
            }, authParams);
            const headers = this.buildHeaders(token);
            const response = await this.apiClient({
                method: 'GET',
                url: path,
                responseType: 'stream',
                headers,
                signal: abortSignal,
            });
            const originalFilename = this.parseFilename(response);
            const usedFilename = filename || originalFilename;
            const writer = (0, node_fs_1.createWriteStream)(usedFilename, { flags: 'wx' });
            response.data.pipe(writer);
            await finished(writer);
            return { usedFilename, originalFilename };
        }
        catch (error) {
            throw new ledger_sdk_error_1.LedgerSdkError(error);
        }
        finally {
            abortController.abort();
        }
    }
}
exports.ReportClient = ReportClient;
//# sourceMappingURL=report-client.js.map