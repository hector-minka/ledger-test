/**
 * @module RecordBuilder / SignReportBuilder
 * @category Record Builders
 */
import { LedgerProof, LedgerReport, ReportMeta, ReportProofCustom, ReportRecord } from "../../../types/src";
import { BaseCompositeBuilder } from '../common/services/base-composite-builder';
import { RequestOptions } from '../common/types/request-options';
import { ReportResponse } from './report-client';
type SendSignatureFunction = (signature: LedgerProof<ReportProofCustom>, reqOptions?: RequestOptions) => Promise<ReportResponse>;
/**
 * Specific builder for adding signatures to ledger reports.
 * Report content cannot be modified, the only updates allowed
 * on reports are adding signatures which are used to control
 * report processing.
 *
 * @example
 * // Adding a new signature to an existing report
 * const { report } = await sdk.report
 *  .from(ledgerReport)
 *  .hash()
 *  .sign([{
 *     keyPair: {
 *       format: keyPair.format,
 *       public: keyPair.public,
 *       secret: keyPair.secret,
 *     },
 *     custom: {
 *       someKey: 'someValue'
 *     }
 *   }])
 *  .send()
 */
export declare class SignReportBuilder extends BaseCompositeBuilder<LedgerReport, ReportResponse, ReportMeta, ReportProofCustom> {
    /**
     * A handler function used to submit a signature to ledger.
     */
    private sendSignature;
    /**
     * New signatures start index. Only signatures from this
     * index are going to be sent to ledger. Earlier signatures
     * existed on the record before it was passed to this builder.
     */
    private newSignaturesStartIndex;
    constructor(sendSignature: SendSignatureFunction, report: ReportRecord);
    /**
     * Sends the new signatures to ledger.
     *
     * @param requestOptions Optional request options to use for this request
     * @returns api response with the updated report
     * @throws if any method in builder chain fails
     */
    send(requestOptions?: RequestOptions): Promise<ReportResponse>;
}
export {};
