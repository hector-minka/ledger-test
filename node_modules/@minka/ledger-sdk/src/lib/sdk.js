"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LedgerSdk = void 0;
/**
 * @module Base / LedgerSdk
 * @category SDK Instance
 */
const axios_1 = __importStar(require("axios"));
const lodash_1 = __importDefault(require("lodash"));
const nanoid_1 = require("nanoid");
const advice_client_1 = require("./advice/advice-client");
const anchor_client_1 = require("./anchor/anchor-client");
const bridge_client_1 = require("./bridge/bridge-client");
const circle_client_1 = require("./circle/circle-client");
const proof_verification_client_1 = require("./common/services/proof-verification-client");
const ledger_sdk_error_1 = require("./common/types/ledger-sdk-error");
const domain_client_1 = require("./domain/domain-client");
const effect_client_1 = require("./effect/effect-client");
const intent_client_1 = require("./intent/intent-client");
const ledger_client_1 = require("./ledger/ledger-client");
const policy_client_1 = require("./policy/policy-client");
const report_client_1 = require("./report/report-client");
const request_client_1 = require("./request/request-client");
const schema_client_1 = require("./schema/schema-client");
const server_access_client_1 = require("./server/server-access-client");
const signer_client_1 = require("./signer/signer-client");
const status_client_1 = require("./status/status-client");
const symbol_client_1 = require("./symbol/symbol-client");
const wallet_client_1 = require("./wallet/wallet-client");
const DEFAULT_TIMEOUT = 15000;
const nanoid = (0, nanoid_1.customAlphabet)('0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz', 21);
/**
 * A lightweight wrapper on top of axios to simplify
 * making requests to the Minka Ledger API.
 */
class LedgerSdk {
    /**
     * Active ledger
     * @see {Ledger}
     */
    activeLedger;
    /**
     * Allows querying the ledger status.
     * @see {LedgerStatus}
     */
    statusClient;
    /**
     * Allows querying and managing ledger instances.
     * @see {Ledger}
     */
    ledger;
    /**
     * Allows querying and managing symbols.
     * @see {LedgerSymbol}
     */
    symbol;
    /**
     * Allows querying and managing schemas.
     * @see {LedgerSchema}
     */
    schema;
    /**
     * Allows querying and managing bridges.
     * @see {LedgerBridge}
     */
    bridge;
    /**
     * Allows querying and managing circles.
     * @see {LedgerCircle}
     */
    circle;
    /**
     * Allows querying and managing wallets.
     * @see {LedgerWallet}
     */
    wallet;
    /**
     * Allows querying and managing intents.
     * @see {LedgerIntent}
     */
    intent;
    /**
     * Allows querying and managing intents.
     * @see {LedgerPolicy}
     */
    policy;
    /**
     * Allows querying and managing signers.
     * @see {LedgerSigner}
     */
    signer;
    /**
     * Allows querying and managing effects.
     * @see {LedgerEffect}
     */
    effect;
    /**
     * Allows querying of requests.
     * @see {LedgerRequest}
     */
    request;
    /**
     * Allows querying and managing anchors.
     * @see {LedgerAnchor}
     */
    anchor;
    /**
     * Allows querying and managing domains.
     * @see {LedgerDomain}
     */
    domain;
    /**
     * Allows querying and managing access.
     * @see {AccessDomain}
     */
    access;
    /**
     * Allows querying and managing report.
     * @see {LedgerReport}
     */
    report;
    /**
     * Allows executing advices.
     * @see {AdviceAliasResolveResult}
     */
    advice;
    /**
     * Allows handle generation by using the
     * unique method.
     */
    handle;
    /**
     * Property containing the available SDK options
     * of the current instance.
     */
    options;
    /**
     * List of multi tenant clients managed in the SDK.
     */
    multiTenantClients;
    /**
     * List of single tenant clients managed in the SDK.
     */
    singleTenantClients;
    /**
     * List of clients managed in the SDK.
     */
    clients;
    constructor(options) {
        options = lodash_1.default.cloneDeep(options);
        if (options.server.endsWith('/')) {
            const error = new Error(`Base URL shouldn't have a trailing slash: ${options.server}`);
            throw new ledger_sdk_error_1.LedgerSdkError(error);
        }
        if (options.verifyResponseProofs && !options.signer) {
            throw new Error(`Ledger signer is required to verify response proofs automatically`);
        }
        const apiClient = axios_1.default.create({
            baseURL: options.server,
            timeout: options.timeout || DEFAULT_TIMEOUT,
        });
        if (options.verifyResponseProofs) {
            /**
             * Intercept all responses and verify the proofs
             * before returning the response.
             */
            const verificationClient = new proof_verification_client_1.ProofVerificationClient(options.signer);
            verificationClient.ledger();
            apiClient.interceptors.response.use(async (response) => {
                /**
                 * Empty URL means that the request was made
                 * to the status endpoint. Status responses
                 * aren't signed.
                 */
                if (response.config.url === '') {
                    return response;
                }
                await verificationClient.verify(response.data);
                return response;
            }, async (error) => {
                if (error instanceof axios_1.AxiosError) {
                    /**
                     * Empty URL means that the request was made
                     * to the status endpoint. Status responses
                     * aren't signed.
                     */
                    if (error.config.url === '') {
                        return Promise.reject(error);
                    }
                    await verificationClient.verify(error.response?.data);
                }
                return Promise.reject(error);
            });
        }
        // Status API should be open without JWT
        this.statusClient = new status_client_1.StatusClient({
            apiClient,
            ledger: options.ledger,
            headers: options.headers,
        });
        const clientOptions = {
            apiClient,
            secure: options.secure,
            ledger: options.ledger,
            headers: options.headers,
        };
        this.ledger = new ledger_client_1.LedgerClient(clientOptions);
        this.symbol = new symbol_client_1.SymbolClient(clientOptions);
        this.schema = new schema_client_1.SchemaClient(clientOptions);
        this.wallet = new wallet_client_1.WalletClient(clientOptions);
        this.intent = new intent_client_1.IntentClient(clientOptions);
        this.signer = new signer_client_1.SignerClient(clientOptions);
        this.effect = new effect_client_1.EffectClient(clientOptions);
        this.bridge = new bridge_client_1.BridgeClient(clientOptions);
        this.circle = new circle_client_1.CircleClient(clientOptions);
        this.policy = new policy_client_1.PolicyClient(clientOptions);
        this.request = new request_client_1.RequestClient(clientOptions);
        this.anchor = new anchor_client_1.AnchorClient(clientOptions);
        this.domain = new domain_client_1.DomainClient(clientOptions);
        this.report = new report_client_1.ReportClient(clientOptions);
        this.advice = new advice_client_1.AdviceClient(clientOptions);
        this.access = new server_access_client_1.ServerAccessClient(clientOptions);
        this.multiTenantClients = [
            this.symbol,
            this.schema,
            this.wallet,
            this.intent,
            this.signer,
            this.effect,
            this.bridge,
            this.circle,
            this.policy,
            this.request,
            this.anchor,
            this.domain,
            this.report,
            this.advice,
            this.ledger,
        ];
        this.singleTenantClients = [this.access, this.statusClient];
        this.clients = [...this.multiTenantClients, ...this.singleTenantClients];
        this.handle = {
            unique: () => {
                return nanoid();
            },
        };
        this.options = options;
    }
    /**
     * Sets authentication parameters on all clients.
     * @param authParams authentication parameters
     */
    setAuthParams(authParams) {
        authParams = lodash_1.default.cloneDeep(authParams);
        for (const client of this.clients) {
            client.setAuthParams(authParams);
        }
    }
    /**
     * Sets global headers on clients. This will affect every request made with this instance of the SDK.
     * @param key Header key
     * @param value Header value
     */
    setHeader(key, value) {
        for (const client of this.clients) {
            client.setHeader(key, value);
        }
    }
    /**
     * Sets active ledger on all multi-tenant clients.
     * @param handle ledger handle
     */
    setActiveLedger(handle) {
        this.activeLedger = handle;
        for (const client of this.multiTenantClients) {
            client.setActiveLedger(handle);
        }
    }
    /**
     * Gets active ledger
     * @returns active ledger handle
     */
    getActiveLedger() {
        return this.activeLedger;
    }
    /**
     * Returns the basic info about a ledger instance. This request
     * can be used to validate ledger URLs and to check if an instance
     * is up and running.
     *
     * @see {LedgerStatus}
     * @returns the ledger status info
     */
    async status() {
        return this.statusClient.read();
    }
    /**
     * Sets the public signer used to verify signatures of
     * the ledger responses
     * @param signer the ledger signer
     * @returns this instance for chaining
     */
    setSigner(signer) {
        signer = lodash_1.default.cloneDeep(signer);
        this.options.signer = signer;
        return this;
    }
    /**
     * Get a new instance of the proof verification client
     * which can be used to verify proofs of ledger records.
     * `expect`, `ledger` and `length` methods can be used to
     * add additional assertions to the `verify` method.
     * By default the verification client has only one assertion
     * to verify that the record has at least 1 proof.
     * @returns the proof verification client
     */
    get proofs() {
        return new proof_verification_client_1.ProofVerificationClient(this.options.signer);
    }
}
exports.LedgerSdk = LedgerSdk;
//# sourceMappingURL=sdk.js.map