"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SignerClient = exports.SignersResponse = exports.SignerResponse = void 0;
const lodash_1 = __importDefault(require("lodash"));
const access_client_1 = require("../common/clients/access-client");
const base_change_client_1 = require("../common/clients/base-change-client");
const base_client_1 = require("../common/clients/base-client");
const update_record_builder_1 = require("../common/services/update-record-builder");
const base_record_response_1 = require("../common/types/base-record-response");
const list_response_1 = require("../common/types/list-response");
const signer_circle_client_1 = require("./signer-circle-client");
const signer_factor_client_1 = require("./signer-factor-client");
const signer_record_builder_1 = require("./signer-record-builder");
const SIGNERS_PATH = '/signers';
/**
 * Single signer API response.
 */
class SignerResponse extends base_record_response_1.BaseRecordResponse {
    /**
     * Record data extracted from the `data` property of the response body.
     */
    signer;
    constructor(response) {
        super(response);
        this.signer = response?.data?.data;
    }
}
exports.SignerResponse = SignerResponse;
/**
 * Signers list API response.
 */
class SignersResponse extends list_response_1.BaseListResponse {
    /**
     * A flattened list of records, extracted from the `data` property of
     * each record returned.
     */
    signers;
    constructor(response) {
        super(response);
        this.signers = response?.data?.data?.map((record) => record.data);
    }
}
exports.SignersResponse = SignersResponse;
/**
 * Allows querying the ledger signers.
 *
 * @see {LedgerSigner}
 */
class SignerClient extends base_client_1.BaseClient {
    /**
     * Allows querying and managing circle signers.
     *
     * @see {LedgerCircleSigner}
     */
    circle;
    /**
     * Allows querying and managing signer factors.
     *
     * @see {LedgerFactor}
     */
    factor;
    /**
     * Allows querying changes.
     *
     */
    change;
    /**
     * Allows checking access.
     *
     */
    access;
    constructor(options) {
        super(options);
        this.change = new base_change_client_1.BaseChangeClient(options, SIGNERS_PATH);
        this.circle = new signer_circle_client_1.SignerCircleClient(options, SIGNERS_PATH);
        this.access = new access_client_1.AccessClient(options, SIGNERS_PATH);
        this.factor = new signer_factor_client_1.SignerFactorClient(options, SIGNERS_PATH);
        this.links = [this.change, this.circle, this.access, this.factor];
    }
    /**
     * Initializes a builder instance that supports chaining to make it
     * easier to work with ledger records. You can pass the record
     * payload to this method to use as initial content, this is useful
     * when you already have an object ready, for example when validating
     * API responses or modifying an existing record. An empty record is
     * going to be created if no initial data is provided.
     *
     * @see {LedgerSigner}
     * @see {SignerRecordBuilder}
     * @param options.record initial record payload (optional)
     * @param options.handle specify handle to be updated, if any (optional)
     * @returns a builder instance
     */
    init(record) {
        const builder = new signer_record_builder_1.SignerRecordBuilder(async (record, reqOptions) => {
            return this.createRecord(SIGNERS_PATH, SignerResponse, record, reqOptions);
        });
        record = lodash_1.default.cloneDeep(record);
        return builder.init(record);
    }
    /**
     * Initializes a builder instance for updating existing records.
     * The builder supports chaining to make it easier to work with
     * ledger records. You can pass the existing record payload to
     * this method to use as initial content.
     *
     * @see {LedgerSigner}
     * @see {UpdateRecordBuilder}
     * @param record initial record payload
     * @param moment record state time
     * @returns a builder instance
     */
    from(record) {
        const builder = new update_record_builder_1.UpdateRecordBuilder(async (record, reqOptions) => {
            return this.updateRecord(`${SIGNERS_PATH}/${encodeURIComponent(record.data.handle)}`, SignerResponse, record, reqOptions);
        }, async (proof, reqOptions) => {
            return this.signRecord(`${SIGNERS_PATH}/${encodeURIComponent(record.data.handle)}/proofs`, SignerResponse, proof, reqOptions);
        });
        record = lodash_1.default.cloneDeep(record);
        return builder.init(record);
    }
    /**
     * Gets a ledger signer by identifier (luid or handle).
     *
     * @see {LedgerSigner}
     * @throws {Error} if the signer doesn't exist or the
     *   current user doesn't have access to this signer
     * @param id a unique signer identifier
     * @returns a single signer response with the requested signer
     */
    async read(id, options) {
        return this.getRecord(`${SIGNERS_PATH}/${encodeURIComponent(id)}`, SignerResponse, options);
    }
    /**
     * Queries signers from a ledger.
     *
     * @see {LedgerSigner}
     * @param params query parameters
     * @returns signers list response with all found wallets
     */
    async list(params) {
        return this.getRecordsList(SIGNERS_PATH, SignersResponse, params);
    }
}
exports.SignerClient = SignerClient;
//# sourceMappingURL=signer-client.js.map