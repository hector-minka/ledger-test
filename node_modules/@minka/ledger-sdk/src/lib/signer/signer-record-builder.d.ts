import { LedgerCustom, LedgerKeyPair, LedgerSigner } from "../../../types/src";
import { CreateRecordBuilder } from '../common/services/create-record-builder';
import { SignerResponse } from './signer-client';
import { SignerRecordReadOptions } from './signer-read-params';
/**
 * Specific builder for working with signer ledger records which
 * adds functionalities for working with keys in signer record.
 *
 * NOTE: current record instance is mutated by this
 * class, we are not cloning instances intentionally,
 * and it isn't advised to reuse builder instances when
 * working with multiple records or mutating objects
 * passed to this builder in external code. It is
 * recommended to clone objects in such cases to avoid
 * unexpected behaviors.
 *
 * @example
 * // Creating and storing signer with password encrypted key
 * const { signer } = await sdk.signer
 *  .init()
 *  .data({
 *    handle: 'tesla',
 *    custom: {
 *      type: 'SHARES'
 *    },
 *    public: '...',
 *    secret: '...',
 *  })
 *  .code('password')
 *  .hash()
 *  .lock()
 *  .send()
 *
 * @example
 * // Creating and storing signer generating keypair with keys method
 * const { signer } = await sdk.signer
 *  .init()
 *  .data({
 *    handle: 'tesla',
 *    custom: {
 *      type: 'SHARES'
 *    },
 *  })
 *  .keys({
 *    format: 'ed25519-raw'
 *  })
 *  .code('password')
 *  .hash()
 *  .lock()
 *  .send()
 *
 * @extends {CreateRecordBuilder<LedgerSigner,SignerResponse>}
 */
export declare class SignerRecordBuilder extends CreateRecordBuilder<LedgerSigner, SignerResponse> {
    private password;
    /**
     * Decrypts secret with current builder's password.
     *
     * @param secret encrypted secret payload
     * @returns decrypted secret
     * @throws if password is not set in builder with `.code(password)`
     */
    private decryptSecret;
    /**
     * Extracts plain key pair from current record in builder which can
     * be used for signing/verification.
     *
     * @returns key pair object
     * @throws if any of key pair components are missing in builder record
     * or if decryption password is not set for encrypted secret
     */
    private extractKeyPair;
    /**
     * Sets password used for secret key encryption/decryption. If secret
     * key in current record is not yet encrypted plain, it will be encrypted
     * with given password.
     *
     * @param password encryption password
     * @returns this builder instance for chaining
     */
    code(password: string): this;
    /**
     * Signs a signer record with own secret key and assigns own
     * public key as owner as the record in `access` property.
     *
     * @params custom proof custom data
     * @returns this builder instance for chaining
     */
    lock(custom?: LedgerCustom): this;
    /**
     * Returns (a clone of) the constructed record. Modifying the return wil not affect the builder.
     * @param readOptions options for reading the current record
     * @returns the constructed record
     */
    read(readOptions?: SignerRecordReadOptions): Promise<import("../../../types/src").LedgerRecord<LedgerSigner, import("../../../types/src").LedgerMeta>>;
    /**
     * Sets a key pair to the current record in builder if it's completely
     * provided or generates a new one based on key format determined by
     * user.
     *
     * @example
     * // Creating a new key pair based on
     * // format provided
     * const keyPair = await sdk.signer
     *  .init()
     *  .keys({ format: 'ed25519-raw' })
     *
     * @example
     * // Setting a key pair to record
     * const keyPair = await sdk.signer
     *  .init()
     *  .keys({
     *    format: 'ed25519-raw',
     *    public: 'bCATFCTY3emZK2MiMq4deF000Elwcnj1VgDku+1jIWY=',
     *    secret: 'iSK3k4rhn4noE1tN91346pMRfuR7LeiTTRAHg404YZ0='
     *  })
     *
     * @returns this builder instance for chaining
     * @throws if key format is not provided or it's not supported
     */
    keys(keyPair: Partial<LedgerKeyPair>): this;
}
