"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SignerRecordBuilder = void 0;
/**
 * @module RecordBuilder / SignRecordBuilder
 * @category Record Builders
 */
const lodash_1 = __importDefault(require("lodash"));
const crypto_1 = require("../../../crypto/src");
const format_1 = require("../../../format/src");
const types_1 = require("../../../types/src");
const create_record_builder_1 = require("../common/services/create-record-builder");
/**
 * Specific builder for working with signer ledger records which
 * adds functionalities for working with keys in signer record.
 *
 * NOTE: current record instance is mutated by this
 * class, we are not cloning instances intentionally,
 * and it isn't advised to reuse builder instances when
 * working with multiple records or mutating objects
 * passed to this builder in external code. It is
 * recommended to clone objects in such cases to avoid
 * unexpected behaviors.
 *
 * @example
 * // Creating and storing signer with password encrypted key
 * const { signer } = await sdk.signer
 *  .init()
 *  .data({
 *    handle: 'tesla',
 *    custom: {
 *      type: 'SHARES'
 *    },
 *    public: '...',
 *    secret: '...',
 *  })
 *  .code('password')
 *  .hash()
 *  .lock()
 *  .send()
 *
 * @example
 * // Creating and storing signer generating keypair with keys method
 * const { signer } = await sdk.signer
 *  .init()
 *  .data({
 *    handle: 'tesla',
 *    custom: {
 *      type: 'SHARES'
 *    },
 *  })
 *  .keys({
 *    format: 'ed25519-raw'
 *  })
 *  .code('password')
 *  .hash()
 *  .lock()
 *  .send()
 *
 * @extends {CreateRecordBuilder<LedgerSigner,SignerResponse>}
 */
class SignerRecordBuilder extends create_record_builder_1.CreateRecordBuilder {
    password;
    /**
     * Decrypts secret with current builder's password.
     *
     * @param secret encrypted secret payload
     * @returns decrypted secret
     * @throws if password is not set in builder with `.code(password)`
     */
    async decryptSecret(secret) {
        if (!this.password) {
            throw new Error(`Unable to decrypt secret without password, use '.code(password)'` +
                ` before calling '.keys()'`);
        }
        return (0, crypto_1.decryptSecretKey)(secret, this.password);
    }
    /**
     * Extracts plain key pair from current record in builder which can
     * be used for signing/verification.
     *
     * @returns key pair object
     * @throws if any of key pair components are missing in builder record
     * or if decryption password is not set for encrypted secret
     */
    async extractKeyPair() {
        if (!this.record.data.format ||
            !this.record.data.public ||
            !this.record.data.secret) {
            throw new Error(`Incomplete key pair in signer record, use '.data({ format, public, secret })'` +
                ` or '.init()' before calling '.lock()' or '.keys()'`);
        }
        const secret = (0, crypto_1.isSecretKeyEncrypted)(this.record.data.secret)
            ? await this.decryptSecret(this.record.data.secret)
            : this.record.data.secret;
        return {
            format: this.record.data.format,
            public: this.record.data.public,
            secret,
        };
    }
    /**
     * Sets password used for secret key encryption/decryption. If secret
     * key in current record is not yet encrypted plain, it will be encrypted
     * with given password.
     *
     * @param password encryption password
     * @returns this builder instance for chaining
     */
    code(password) {
        this.enqueueAsyncOperation(async () => {
            this.password = password;
            if (this.record.data.secret &&
                !(0, crypto_1.isSecretKeyEncrypted)(this.record.data.secret)) {
                this.record.data.secret = await (0, crypto_1.encryptSecretKey)(this.record.data.secret, password);
            }
        });
        return this;
    }
    /**
     * Signs a signer record with own secret key and assigns own
     * public key as owner as the record in `access` property.
     *
     * @params custom proof custom data
     * @returns this builder instance for chaining
     */
    lock(custom) {
        this.enqueueAsyncOperation(async () => {
            const hash = this.record.hash;
            if (!hash) {
                throw new Error(`Invalid record hash, set a hash by calling '.hash()' ` +
                    `before attempting to lock a record.`);
            }
            let proofCustom;
            if (custom) {
                // Add moment just in case it's not provided
                proofCustom = {
                    moment: (0, format_1.formatDate)(),
                    ...custom,
                };
            }
            // Sign with own key pair
            const keyPair = await this.extractKeyPair();
            this.record.meta.proofs.push(await (0, crypto_1.signHash)(hash, keyPair, proofCustom));
        });
        return this;
    }
    /**
     * Returns (a clone of) the constructed record. Modifying the return wil not affect the builder.
     * @param readOptions options for reading the current record
     * @returns the constructed record
     */
    async read(readOptions) {
        const record = lodash_1.default.cloneDeep(await super.read());
        const { data } = record;
        if (readOptions?.plain) {
            if (data.secret && (0, crypto_1.isSecretKeyEncrypted)(data.secret)) {
                if (!this.password) {
                    throw new Error(`Unable to decrypt secret without password, use '.code(password)'` +
                        ` before calling '.keys()'`);
                }
                data.secret = await (0, crypto_1.decryptSecretKey)(data.secret, this.password);
            }
        }
        return record;
    }
    /**
     * Sets a key pair to the current record in builder if it's completely
     * provided or generates a new one based on key format determined by
     * user.
     *
     * @example
     * // Creating a new key pair based on
     * // format provided
     * const keyPair = await sdk.signer
     *  .init()
     *  .keys({ format: 'ed25519-raw' })
     *
     * @example
     * // Setting a key pair to record
     * const keyPair = await sdk.signer
     *  .init()
     *  .keys({
     *    format: 'ed25519-raw',
     *    public: 'bCATFCTY3emZK2MiMq4deF000Elwcnj1VgDku+1jIWY=',
     *    secret: 'iSK3k4rhn4noE1tN91346pMRfuR7LeiTTRAHg404YZ0='
     *  })
     *
     * @returns this builder instance for chaining
     * @throws if key format is not provided or it's not supported
     */
    keys(keyPair) {
        keyPair = lodash_1.default.cloneDeep(keyPair);
        this.enqueueAsyncOperation(async () => {
            (0, crypto_1.assertKeyFormat)(keyPair.format);
            /**
             * The key pair provided must contain all the
             * properties of a ledger key pair, otherwise
             * it will be replaced by a new one
             */
            if (!keyPair.public || !keyPair.secret) {
                keyPair = await (0, crypto_1.createKeyPair)();
            }
            this.record.data.public = keyPair.public;
            this.record.data.format = keyPair.format;
            this.record.data.secret = keyPair.secret;
            // Make own key pair owner
            // if access object isn't already set
            this.record.data.access = this.record.data.access || [
                {
                    action: types_1.AccessAction.Any,
                    signer: {
                        public: keyPair.public,
                    },
                },
            ];
        });
        return this;
    }
}
exports.SignerRecordBuilder = SignerRecordBuilder;
//# sourceMappingURL=signer-record-builder.js.map