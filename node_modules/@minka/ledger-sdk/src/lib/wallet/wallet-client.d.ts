/**
 * @module Clients / Wallets
 * @category Entities
 */
import { AxiosResponse } from 'axios';
import { LedgerAddress, LedgerBalance, LedgerIdentifier, LedgerLimit, LedgerLuid, LedgerPagedList, LedgerRecord, LedgerWallet } from "../../../types/src";
import { AnchorsResponse } from '../anchor/anchor-client';
import { AccessClient } from '../common/clients/access-client';
import { BaseChangeClient } from '../common/clients/base-change-client';
import { BaseClient, BaseClientOptions } from '../common/clients/base-client';
import { CreateRecordBuilder } from '../common/services/create-record-builder';
import { DropRecordBuilder } from '../common/services/drop-record-builder';
import { UpdateRecordBuilder } from '../common/services/update-record-builder';
import { BaseRecordResponse } from '../common/types/base-record-response';
import { BaseListResponse } from '../common/types/list-response';
import { BaseReadOptions } from '../common/types/read-options';
import { DomainsResponse } from './domain-client';
import { WalletAnchorClient } from './wallet-anchor-client';
import { WalletAnchorListParams } from './wallet-anchor-list-params';
import { WalletListBalancesParams } from './wallet-list-balances-params';
import { WalletListDomainParams } from './wallet-list-domain-params';
import { WalletListLimitsParams } from './wallet-list-limits-params';
import { WalletListParams } from './wallet-list-params';
type WalletIdentifier = LedgerAddress | LedgerLuid;
/**
 * Single wallet API response.
 */
export declare class WalletResponse extends BaseRecordResponse<LedgerWallet> {
    /**
     * Record data extracted from the `data` property of the response body.
     */
    wallet: LedgerWallet;
    constructor(response: AxiosResponse<LedgerRecord<LedgerWallet>, LedgerRecord<LedgerWallet>>);
}
/**
 * Wallets list API response.
 */
export declare class WalletsResponse extends BaseListResponse<LedgerWallet> {
    wallets: LedgerWallet[];
    constructor(response: AxiosResponse<LedgerPagedList<LedgerWallet>, void>);
}
/**
 * Balances list API response.
 */
export declare class BalancesResponse extends BaseListResponse<LedgerBalance> {
    /**
     * A flattened list of records, extracted from the `data` property of
     * each record returned.
     */
    balances: LedgerBalance[];
    constructor(response: AxiosResponse<LedgerPagedList<LedgerBalance>, void>);
}
/**
 * Limits list API response.
 */
export declare class LimitsResponse extends BaseListResponse<LedgerLimit> {
    /**
     * A flattened list of records, extracted from the `data` property of
     * each record returned.
     */
    limits: LedgerLimit[];
    constructor(response: AxiosResponse<LedgerPagedList<LedgerLimit>, void>);
}
/**
 * Allows querying and managing wallets.
 *
 * @see {LedgerWallet}
 */
export declare class WalletClient extends BaseClient {
    /**
     * Allows querying wallet anchors.
     *
     * @see {LedgerCircleSigner}
     */
    anchor: WalletAnchorClient;
    /**
     * Allows querying changes.
     *
     */
    change: BaseChangeClient<LedgerWallet>;
    /**
     * Allows checking access.
     *
     */
    access: AccessClient;
    constructor(options: BaseClientOptions);
    /**
     * Initializes a builder instance that supports chaining to make it
     * easier to work with ledger records. You can pass the record
     * payload to this method to use as initial content, this is useful
     * when you already have an object ready, for example when validating
     * API responses or modifying an existing record. An empty record is
     * going to be created if no initial data is provided.
     *
     * @see {LedgerWallet}
     * @see {CreateRecordBuilder}
     * @param options.record initial record payload (optional)
     * @param options.handle specify handle to be updated, if any (optional)
     * @returns a builder instance
     */
    init(record?: Partial<LedgerRecord<LedgerWallet>>): CreateRecordBuilder<LedgerWallet, WalletResponse, import("../../../types/src").LedgerMeta>;
    /**
     * Initializes a builder instance for updating existing records.
     * The builder supports chaining to make it easier to work with
     * ledger records. You can pass the existing record payload to
     * this method to use as initial content.
     *
     * @see {LedgerWallet}
     * @see {UpdateRecordBuilder}
     * @param record initial record payload
     * @returns a builder instance
     */
    from(record: LedgerRecord<LedgerWallet>): UpdateRecordBuilder<LedgerWallet, WalletResponse, import("../../../types/src").LedgerMeta>;
    /**
     * Initializes a builder instance that supports chaining to make it
     * easier to work with ledger records. You can pass the record
     * payload to this method to use as initial content, this is useful
     * when you already have an object ready, for example when validating
     * API responses or modifying an existing record. An empty record is
     * going to be created if no initial data is provided.
     *
     * @see {LedgerWallet}
     * @see {DropRecordBuilder}
     * @param id wallet identifier (optional)
     * @returns a builder instance
     */
    drop(id?: LedgerIdentifier): DropRecordBuilder<LedgerWallet, import("../../../types/src").LedgerMeta>;
    /**
     * Gets a ledger wallet by identifier (luid or address).
     *
     * @see {LedgerWallet}
     * @throws {Error} if the wallet doesn't exist or the
     *   current user doesn't have access to this wallet
     * @param id a unique wallet identifier - luid or address
     * @param authParams authentication parameters
     * @returns a single wallet response with the requested wallet
     */
    read(id: WalletIdentifier, options?: BaseReadOptions): Promise<WalletResponse>;
    /**
     * Queries wallets from a ledger.
     *
     * @see {LedgerWallet}
     * @param params query parameters
     * @returns wallets list response with all found wallets
     */
    list(params?: WalletListParams): Promise<WalletsResponse>;
    /**
     * Queries wallet balances for a specific wallet.
     * Each wallet can contain multiple balances in multiple
     * symbols. The response contains a list of symbols that
     * this wallet has balances in and a balance for each
     * symbol.
     *
     * @see {LedgerWallet}
     * @see {LedgerBalance}
     * @param id wallet identifier - luid or handle
     * @param params query parameters
     * @returns balances list response with found balances
     */
    getBalances(id: WalletIdentifier, params?: WalletListBalancesParams): Promise<BalancesResponse>;
    /**
     * Queries wallet limits for a specific wallet.
     * Each wallet can contain multiple limits for multiple
     * metrics. The response contains a list of metrics that
     * this wallet has limits for and an amount for each
     * metric.
     *
     * @see {LedgerWallet}
     * @see {LedgerLimit}
     * @param id wallet identifier - luid or handle
     * @param params query parameters
     * @returns limit list response with found limits
     */
    getLimits(id: WalletIdentifier, params?: WalletListLimitsParams): Promise<LimitsResponse>;
    /**
     * Queries wallet anchors for a specific wallet.
     *
     * @see {LedgerWallet}
     * @see {LedgerAnchor}
     * @param id wallet  address
     * @param params query parameters
     * @returns anchors list response with found anchors
     */
    getAnchors(id: WalletIdentifier, params?: WalletAnchorListParams): Promise<AnchorsResponse>;
    /**
     * Queries domains corresponding to a wallet address.
     *
     * @see {LedgerWallet}
     * @see {LedgerDomain}
     * @param id wallet address
     * @param params query parameters
     * @returns domains list response with found domains
     */
    getDomains(id: WalletIdentifier, params?: WalletListDomainParams): Promise<DomainsResponse>;
}
export {};
