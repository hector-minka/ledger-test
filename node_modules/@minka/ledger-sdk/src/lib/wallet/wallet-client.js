"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WalletClient = exports.LimitsResponse = exports.BalancesResponse = exports.WalletsResponse = exports.WalletResponse = void 0;
const lodash_1 = __importDefault(require("lodash"));
const anchor_client_1 = require("../anchor/anchor-client");
const access_client_1 = require("../common/clients/access-client");
const base_change_client_1 = require("../common/clients/base-change-client");
const base_client_1 = require("../common/clients/base-client");
const create_record_builder_1 = require("../common/services/create-record-builder");
const drop_record_builder_1 = require("../common/services/drop-record-builder");
const update_record_builder_1 = require("../common/services/update-record-builder");
const base_record_response_1 = require("../common/types/base-record-response");
const list_response_1 = require("../common/types/list-response");
const domain_client_1 = require("./domain-client");
const wallet_anchor_client_1 = require("./wallet-anchor-client");
const WALLETS_PATH = '/wallets';
/**
 * Single wallet API response.
 */
class WalletResponse extends base_record_response_1.BaseRecordResponse {
    /**
     * Record data extracted from the `data` property of the response body.
     */
    wallet;
    constructor(response) {
        super(response);
        this.wallet = response?.data?.data;
    }
}
exports.WalletResponse = WalletResponse;
/**
 * Wallets list API response.
 */
class WalletsResponse extends list_response_1.BaseListResponse {
    wallets;
    constructor(response) {
        super(response);
        this.wallets = response?.data?.data?.map((record) => record.data);
    }
}
exports.WalletsResponse = WalletsResponse;
/**
 * Balances list API response.
 */
class BalancesResponse extends list_response_1.BaseListResponse {
    /**
     * A flattened list of records, extracted from the `data` property of
     * each record returned.
     */
    balances;
    constructor(response) {
        super(response);
        this.balances = response?.data?.data?.map((record) => record.data);
    }
}
exports.BalancesResponse = BalancesResponse;
/**
 * Limits list API response.
 */
class LimitsResponse extends list_response_1.BaseListResponse {
    /**
     * A flattened list of records, extracted from the `data` property of
     * each record returned.
     */
    limits;
    constructor(response) {
        super(response);
        this.limits = response?.data?.data?.map((record) => record.data);
    }
}
exports.LimitsResponse = LimitsResponse;
/**
 * Allows querying and managing wallets.
 *
 * @see {LedgerWallet}
 */
class WalletClient extends base_client_1.BaseClient {
    /**
     * Allows querying wallet anchors.
     *
     * @see {LedgerCircleSigner}
     */
    anchor;
    /**
     * Allows querying changes.
     *
     */
    change;
    /**
     * Allows checking access.
     *
     */
    access;
    constructor(options) {
        super(options);
        this.anchor = new wallet_anchor_client_1.WalletAnchorClient(options, WALLETS_PATH);
        this.change = new base_change_client_1.BaseChangeClient(options, WALLETS_PATH);
        this.access = new access_client_1.AccessClient(options, WALLETS_PATH);
        this.links = [this.anchor, this.change, this.access];
    }
    /**
     * Initializes a builder instance that supports chaining to make it
     * easier to work with ledger records. You can pass the record
     * payload to this method to use as initial content, this is useful
     * when you already have an object ready, for example when validating
     * API responses or modifying an existing record. An empty record is
     * going to be created if no initial data is provided.
     *
     * @see {LedgerWallet}
     * @see {CreateRecordBuilder}
     * @param options.record initial record payload (optional)
     * @param options.handle specify handle to be updated, if any (optional)
     * @returns a builder instance
     */
    init(record) {
        const builder = new create_record_builder_1.CreateRecordBuilder(async (record, reqOptions) => {
            return this.createRecord(WALLETS_PATH, WalletResponse, record, reqOptions);
        });
        record = lodash_1.default.cloneDeep(record);
        return builder.init(record);
    }
    /**
     * Initializes a builder instance for updating existing records.
     * The builder supports chaining to make it easier to work with
     * ledger records. You can pass the existing record payload to
     * this method to use as initial content.
     *
     * @see {LedgerWallet}
     * @see {UpdateRecordBuilder}
     * @param record initial record payload
     * @returns a builder instance
     */
    from(record) {
        const builder = new update_record_builder_1.UpdateRecordBuilder(async (record, reqOptions) => {
            return this.updateRecord(`${WALLETS_PATH}/${encodeURIComponent(record.data.handle)}`, WalletResponse, record, reqOptions);
        }, async (proof, reqOptions) => {
            return this.signRecord(`${WALLETS_PATH}/${encodeURIComponent(record.data.handle)}/proofs`, WalletResponse, proof, reqOptions);
        });
        record = lodash_1.default.cloneDeep(record);
        return builder.init(record);
    }
    /**
     * Initializes a builder instance that supports chaining to make it
     * easier to work with ledger records. You can pass the record
     * payload to this method to use as initial content, this is useful
     * when you already have an object ready, for example when validating
     * API responses or modifying an existing record. An empty record is
     * going to be created if no initial data is provided.
     *
     * @see {LedgerWallet}
     * @see {DropRecordBuilder}
     * @param id wallet identifier (optional)
     * @returns a builder instance
     */
    drop(id) {
        const WalletIdentifier = id || this.id;
        const builder = new drop_record_builder_1.DropRecordBuilder(async (record, reqOptions) => {
            return this.dropRecord(`${WALLETS_PATH}/${encodeURIComponent(WalletIdentifier)}`, record, reqOptions);
        }, async (options) => {
            const response = await this.read(WalletIdentifier, options);
            return {
                data: response.wallet,
                hash: response.hash,
                luid: response.luid,
                meta: response.meta,
            };
        });
        return builder.init();
    }
    /**
     * Gets a ledger wallet by identifier (luid or address).
     *
     * @see {LedgerWallet}
     * @throws {Error} if the wallet doesn't exist or the
     *   current user doesn't have access to this wallet
     * @param id a unique wallet identifier - luid or address
     * @param authParams authentication parameters
     * @returns a single wallet response with the requested wallet
     */
    async read(id, options) {
        return this.getRecord(`${WALLETS_PATH}/${encodeURIComponent(id)}`, WalletResponse, options);
    }
    /**
     * Queries wallets from a ledger.
     *
     * @see {LedgerWallet}
     * @param params query parameters
     * @returns wallets list response with all found wallets
     */
    async list(params) {
        return this.getRecordsList(WALLETS_PATH, WalletsResponse, params);
    }
    /**
     * Queries wallet balances for a specific wallet.
     * Each wallet can contain multiple balances in multiple
     * symbols. The response contains a list of symbols that
     * this wallet has balances in and a balance for each
     * symbol.
     *
     * @see {LedgerWallet}
     * @see {LedgerBalance}
     * @param id wallet identifier - luid or handle
     * @param params query parameters
     * @returns balances list response with found balances
     */
    async getBalances(id, params) {
        return this.getRecordsList(`${WALLETS_PATH}/${encodeURIComponent(id)}/balances`, BalancesResponse, params);
    }
    /**
     * Queries wallet limits for a specific wallet.
     * Each wallet can contain multiple limits for multiple
     * metrics. The response contains a list of metrics that
     * this wallet has limits for and an amount for each
     * metric.
     *
     * @see {LedgerWallet}
     * @see {LedgerLimit}
     * @param id wallet identifier - luid or handle
     * @param params query parameters
     * @returns limit list response with found limits
     */
    async getLimits(id, params) {
        return this.getRecordsList(`${WALLETS_PATH}/${encodeURIComponent(id)}/limits`, LimitsResponse, params);
    }
    /**
     * Queries wallet anchors for a specific wallet.
     *
     * @see {LedgerWallet}
     * @see {LedgerAnchor}
     * @param id wallet  address
     * @param params query parameters
     * @returns anchors list response with found anchors
     */
    async getAnchors(id, params) {
        return this.getRecordsList(`${WALLETS_PATH}/${encodeURIComponent(id)}/anchors`, anchor_client_1.AnchorsResponse, params);
    }
    /**
     * Queries domains corresponding to a wallet address.
     *
     * @see {LedgerWallet}
     * @see {LedgerDomain}
     * @param id wallet address
     * @param params query parameters
     * @returns domains list response with found domains
     */
    async getDomains(id, params) {
        return this.getRecordsList(`${WALLETS_PATH}/${encodeURIComponent(id)}/domains`, domain_client_1.DomainsResponse, params);
    }
}
exports.WalletClient = WalletClient;
//# sourceMappingURL=wallet-client.js.map