import { AccessAction } from '../common/ledger-access';
import { LedgerHandle } from '../common/ledger-handle';
import { LedgerMeta, LedgerProof } from '../common/ledger-meta';
import { Ledger } from '../records/ledger';
import { LedgerBridge } from '../records/ledger-bridge';
import { LedgerCircle, LedgerCircleSigner } from '../records/ledger-circle';
import { LedgerDomain } from '../records/ledger-domain';
import { LedgerEffect } from '../records/ledger-effect';
import { LedgerIntent } from '../records/ledger-intent';
import { LedgerPolicy } from '../records/ledger-policy';
import { LedgerSchema, SchemaContent } from '../records/ledger-schema';
import { LedgerSigner, LedgerSigningParams } from '../records/ledger-signer';
import { LedgerSymbol } from '../records/ledger-symbol';
import { LedgerWallet } from '../records/ledger-wallet';
export declare enum LayoutRecord {
    Schema = "schema",
    Bridge = "bridge",
    Wallet = "wallet",
    Circle = "circle",
    Policy = "policy",
    Symbol = "symbol",
    Signer = "signer",
    Intent = "intent",
    Effect = "effect",
    Domain = "domain",
    Ledger = "ledger",
    SignerProof = "signer-proof",
    CircleSigner = "circle-signer"
}
export declare const LayoutRecords: LayoutRecord[];
export type LayoutInputs = SchemaContent;
export type LayoutCustom = {
    title: string;
    version?: string;
    inputs?: LayoutInputs;
};
export type BaseLayoutExec = {
    action?: AccessAction.Create | AccessAction.Update | AccessAction.Drop;
    merge?: boolean;
    domain?: null | string;
    keyPair?: `key@${LedgerHandle}`;
};
export type CircleLayoutExec = BaseLayoutExec & {
    members?: LedgerHandle | LedgerHandle[];
};
export type SignerLayoutExec = BaseLayoutExec & {
    circles?: LedgerHandle | LedgerHandle[];
    password?: string;
};
export type ProofLayoutExec = BaseLayoutExec & {
    handle: LedgerHandle;
};
export type BaseLayoutSign = LedgerSigningParams;
export type BaseRecordValue<TRecordData, TLayoutExec extends BaseLayoutExec = BaseLayoutExec, TRecordMeta = Record<string, never>> = {
    data: Partial<TRecordData>;
    meta?: Partial<TRecordMeta>;
    exec?: TLayoutExec;
    sign?: BaseLayoutSign;
};
export type LayoutRecordsMap = Partial<{
    [LayoutRecord.Schema]: BaseRecordValue<LedgerSchema>[];
    [LayoutRecord.Bridge]: BaseRecordValue<LedgerBridge, BaseLayoutExec, LedgerMeta>[];
    [LayoutRecord.Wallet]: BaseRecordValue<LedgerWallet>[];
    [LayoutRecord.Circle]: BaseRecordValue<LedgerCircle, CircleLayoutExec>[];
    [LayoutRecord.Policy]: BaseRecordValue<LedgerPolicy>[];
    [LayoutRecord.Symbol]: BaseRecordValue<LedgerSymbol>[];
    [LayoutRecord.Signer]: BaseRecordValue<LedgerSigner, SignerLayoutExec>[];
    [LayoutRecord.Intent]: BaseRecordValue<LedgerIntent>[];
    [LayoutRecord.Effect]: BaseRecordValue<LedgerEffect>[];
    [LayoutRecord.Domain]: BaseRecordValue<LedgerDomain>[];
    [LayoutRecord.Ledger]: BaseRecordValue<Ledger>[];
    [LayoutRecord.SignerProof]: BaseRecordValue<LedgerProof<any>, ProofLayoutExec>[];
    [LayoutRecord.CircleSigner]: BaseRecordValue<LedgerCircleSigner>[];
}>;
/**
 * @example
 * "{{#each symbols}}": {
 *    "handle": "{{handle}}",
 *    "factor": "{{factor}}"
 * }
 */
type loopKey = `{{#each ${string}}}`;
export type ArrayTemplateFromLoop<TRecordData, TLayoutExec extends BaseLayoutExec = BaseLayoutExec, TRecordMeta = Record<string, never>> = Record<loopKey, BaseRecordValue<TRecordData, TLayoutExec, TRecordMeta>>;
export type LayoutRecordValues<TRecordData, TLayoutExec extends BaseLayoutExec = BaseLayoutExec, TRecordMeta = Record<string, never>> = BaseRecordValue<TRecordData, TLayoutExec, TRecordMeta>[] | ArrayTemplateFromLoop<TRecordData, TLayoutExec, TRecordMeta>;
export type LayoutRecordValue<TRecordData, TLayoutExec extends BaseLayoutExec = BaseLayoutExec, TRecordMeta = Record<string, never>> = BaseRecordValue<TRecordData, TLayoutExec, TRecordMeta>;
export type SchemaLayoutValue = {
    record: LayoutRecord.Schema;
    values: LayoutRecordValues<LedgerSchema>;
};
export type BridgeLayoutValue = {
    record: LayoutRecord.Bridge;
    values: LayoutRecordValues<LedgerBridge, any, LedgerMeta>;
};
export type WalletLayoutValue = {
    record: LayoutRecord.Wallet;
    values: LayoutRecordValues<LedgerWallet>;
};
export type CircleLayoutValue = {
    record: LayoutRecord.Circle;
    values: LayoutRecordValues<LedgerCircle, CircleLayoutExec>;
};
export type CircleSignerLayoutValue = {
    record: LayoutRecord.CircleSigner;
    values: LayoutRecordValues<LedgerCircle>;
};
export type PolicyLayoutValue = {
    record: LayoutRecord.Policy;
    values: LayoutRecordValues<LedgerPolicy>;
};
export type IntentLayoutValue = {
    record: LayoutRecord.Intent;
    values: LayoutRecordValues<LedgerIntent>;
};
export type SignerLayoutValue = {
    record: LayoutRecord.Signer;
    values: LayoutRecordValues<LedgerSigner, SignerLayoutExec>;
};
export type DomainLayoutValue = {
    record: LayoutRecord.Domain;
    values: LayoutRecordValues<LedgerDomain>;
};
export type EffectLayoutValue = {
    record: LayoutRecord.Effect;
    values: LayoutRecordValues<LedgerEffect>;
};
export type SymbolLayoutValue = {
    record: LayoutRecord.Symbol;
    values: LayoutRecordValues<LedgerSymbol>;
};
export type LedgerLayoutValue = {
    record: LayoutRecord.Ledger;
    values: LayoutRecordValues<Ledger>;
};
export type SignerProofLayoutValue = {
    record: LayoutRecord.SignerProof;
    values: LayoutRecordValues<LedgerProof>;
};
export type LayoutValue = SchemaLayoutValue | BridgeLayoutValue | WalletLayoutValue | CircleLayoutValue | PolicyLayoutValue | IntentLayoutValue | SignerLayoutValue | DomainLayoutValue | EffectLayoutValue | SymbolLayoutValue | LedgerLayoutValue | SignerProofLayoutValue;
/**
 * Standard representation of a ledger layout.
 * It can be used to describe existing ledgers, and
 * consequentially to easily replicate them.
 */
export type LedgerLayout = {
    custom: LayoutCustom;
    values: LayoutValue[];
};
export {};
