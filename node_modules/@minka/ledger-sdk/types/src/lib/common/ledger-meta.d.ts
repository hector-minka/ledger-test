import { LedgerErrorReason } from "../../../../errors/src";
import { LedgerCustom } from './ledger-custom';
import { LedgerHandle } from './ledger-handle';
import { LedgerLabel, LedgerLabelQuery } from './ledger-label';
import { LedgerOwner } from './ledger-owner';
/**
 * Record metadata. This property is not hashed or signed.
 */
export type LedgerMeta<TCustom extends LedgerProofCustom = LedgerProofCustom> = {
    /**
     * Signatures attached to a ledger record that are used
     * to guarantee integrity and non-repudiation.
     *
     * TODO (herman): we probably don't want to constrain all proofs
     * to same type
     */
    proofs: LedgerProof<TCustom>[];
    /**
     * Timestamp of mutation which created
     * or updated the record in DB.
     */
    moment?: string;
    /**
     * Record owners list
     */
    owners?: LedgerOwner;
    /**
     * Record status
     */
    status?: string;
    /**
     * Record labels
     */
    labels?: LedgerLabel[];
    /**
     * The handle of a domain this record is a part of.
     */
    domain?: LedgerHandle;
    /**
     * Plain values of secrets to use in record.
     */
    secret?: {
        [key: string]: string;
    };
};
/**
 * Signatures generated by signing a hash of the ledger
 * record data property with a private key.
 */
export type LedgerProof<TCustom extends LedgerProofCustom = LedgerProofCustom> = {
    /**
     * Signature method, determines the algorithms used to
     * generate hashes and signatures.
     */
    method: 'ed25519-v2';
    /**
     * Public key that can be used to verify a signature,
     * type spki, format der, base64 encoded.
     */
    public: string;
    /**
     * Input digest that was signed. This is usually a hash
     * of the input data that may have been combined with
     * additional signature custom data hash.
     */
    digest: string;
    /**
     * Signature result, base64 encoded.
     */
    result: string;
    /**
     * Custom data attached to signatures which are used
     * to convey additional information that describe why
     * a signature was added to a record.
     */
    custom?: TCustom;
};
/**
 * Represents only ledger signature result without inclusion
 * of custom data. Used internally for low-level signing
 * operations.
 */
export type LedgerSignatureResult = Omit<LedgerProof, 'custom'>;
export declare enum LedgerSignatureStatus {
    Created = "created",
    Updated = "updated",
    Dropped = "dropped"
}
/**
 * Base custom data for all ledger signatures.
 */
export type LedgerProofCustom<TStatus = string> = LedgerCustom & {
    /**
     * Timestamp when the signature was signed
     */
    moment: string;
    /**
     * Status assigned within the proof
     */
    status?: TStatus;
    /**
     * Labels requested
     */
    labels?: LedgerLabelQuery;
    /**
     * Ledger domain to assign to the record.
     */
    domain?: LedgerHandle;
    /**
     * Used to report error reason by external system in case when processing
     * of action fails in external system.
     */
    reason?: LedgerErrorReason;
    /**
     * Text which describes the error if error `reason` is reported.
     */
    detail?: string;
    /**
     * Reference to error in the external system. It is usually an error code
     * specific to external system.
     */
    failId?: string;
    /**
     * Encrypted record secrets to update/add to the record meta.
     */
    secrets?: {
        [k: string]: string;
    };
};
