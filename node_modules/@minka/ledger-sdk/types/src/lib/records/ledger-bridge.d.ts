import { LedgerRecord } from '../base/ledger-record';
import { OperatorShape } from '../common/filter-query-options';
import { InlineSecretReference } from '../common/inline-secret-reference';
import { LedgerAccess } from '../common/ledger-access';
import { LedgerCustom } from '../common/ledger-custom';
import { LedgerBaseData } from '../common/ledger-data';
import { LedgerFilter } from '../common/ledger-filter';
import { LedgerHandle } from '../common/ledger-handle';
/**
 * A bridge represents a ledger configuration record that
 * is used to register remote services with the ledger.
 * This is an optional record in most cases, since remote
 * service calls can usually be specified inline, for
 * example actions in effects, aspects, etc.
 * An example of a bridge is an integration service
 * that connects with a banking core in order to perform
 * debit and credit operations in response to ledger balance
 * movements. Other use cases include services which host webhooks
 * in order to subscribe to ledger events and react to them.
 *
 */
export type LedgerBridge = LedgerBaseData & {
    /**
     * Bridge handle or identifier, handle is used to
     * identify a bridge in our database.
     */
    handle: LedgerHandle;
    /**
     * The schema used to validate this bridge. This is mandatory
     * if there is at least one schema defined for the record
     * type `bridge`.
     */
    schema?: LedgerHandle;
    /**
     * Bridge configuration object
     */
    config: BridgeConfig;
    /**
     *
     */
    secure: BridgeSecurityRule[];
    /**
     * Defines bridge's features enabled.
     * All the traits are enabled by default if
     * this property is not present.
     *
     * Each trait item can either be a string containing the name of the
     * trait or an object with `method` and `filter` properties.
     * Method property should be a string containing the name of the trait
     * and filter property should be an object containing the filter rules.
     *
     * Domains trait can not be filtered because it is used only for a
     * GET request.
     *
     * Effects trait can not be filtered because they can be filtered
     * directly in the effect record with the proper data for that
     * effect signal.
     *
     * The filter targets the `data` part of the request payload.
     */
    traits?: BridgeTraitConfiguration;
    /**
     * Custom metadata, this object can hold any
     * additional data that could be useful to end users
     * or ledger plugins to work with the bridge.
     */
    custom?: LedgerCustom;
    /**
     * Determines access controls of a bridge. This field
     * can be used to limit updates, issuance, etc.
     */
    access?: LedgerAccess;
};
export type BridgeRecord = LedgerRecord<LedgerBridge>;
/**
 * Security rules used to define the authentication and
 * authorization mechanisms using to the bridge to connect
 * from and to the ledger.
 */
export type BridgeSecurityRule = BridgeGenericSecurityRule | BridgeOauthSecurityRule;
/**
 * Generic bridge security rule that can be used for any purpose.
 * It is recommended to still have a specific type for each
 */
export type BridgeGenericSecurityRule = {
    schema: string;
    public: string;
    secret: string;
};
/**
 * Security rules used to define oauth authentication and
 * authorization mechanisms used by ledger when sending requests to the bridge.
 */
export type BridgeOauthSecurityRule = {
    schema: 'oauth2';
    clientId: string;
    clientSecret: InlineSecretReference;
    tokenUrl: string;
};
/**
 * Bridge configuration object which will be shared
 * across all of the bridge functionalities.
 */
export type BridgeConfig = {
    server?: string;
    /**
     * Determines how bridge calls for debit claims are grouped in case multiple claims of
     * one intent are addressed to the same bridge.
     *
     * If not defined, claims are not grouped
     */
    'debits.claims.groupBy'?: BridgeClaimGrouping;
    /**
     * Determines how bridge calls for credit claims are grouped in case multiple claims of
     * one intent are addressed to the same bridge.
     *
     * If not defined, claims are not grouped
     */
    'credits.claims.groupBy'?: BridgeClaimGrouping;
};
/**
 * Determines how bridge calls for claims are grouped in case multiple claims of
 * one intent are addressed to the same bridge.
 */
export declare enum BridgeClaimGrouping {
    /**
     * With this option, claims will be grouped by exact address of `target.handle` of the claims.
     *
     * If there are multiple claims with the same target address,
     * they will be grouped into single credit entry sent to a target bridge.
     */
    address = "address",
    /**
     * With this option, claims will be grouped by the actual wallet resolved as target of the address
     * from `target.handle`
     *
     * If there are multiple claims with different `target.handle`,
     * but they get resolved to the same target wallet (e.g. because of wallet parent hierarchy),
     * these claims will be grouped together.
     *
     * Of course, if the `target.handle` is the same, then the claims will also be grouped together,
     * just like they would have with the `address` grouping setting.
     */
    wallet = "wallet"
}
/**
 * Features of a bridge.
 */
export declare enum BridgeTrait {
    Debits = "debits",
    Credits = "credits",
    /**
     * Can receive intent status calls
     */
    Statuses = "statuses",
    Anchors = "anchors",
    Domains = "domains",
    Effects = "effects"
}
export declare const BridgeTraits: BridgeTrait[];
/**
 * Bridge traits that can not be filtered.
 * Domains because it's used only for a GET request.
 * Effects because they should be filtered directly in the effect record.
 */
export type NonFilterableBridgeTrait = BridgeTrait.Domains | BridgeTrait.Effects;
export type FilterableBridgeTrait = Exclude<BridgeTrait, NonFilterableBridgeTrait>;
/**
 * Legacy bridge features mapped to their newest versions.
 * If a bridge has a legacy trait enabled, its corresponding
 * non-legacy trait is also considered to be enabled.
 */
export declare const LegacyBridgeTrait: {
    effects: string;
};
/**
 * Trait configuration for a bridge, defines which
 * traits are enabled on the bridge and allows to define
 * filters for each trait.
 */
export type BridgeTraitConfiguration = (BridgeTrait | {
    method: FilterableBridgeTrait;
    filter: BridgeTraitFilter;
})[];
/**
 * Options to activate a bridge.
 */
export type BridgeActivationOptions = {
    /**
     * Time in minutes to resume events from.
     */
    offset?: number;
};
/**
 * Filter rules to reject some of the requests for specific traits.
 *
 * Filter targets the `data` part of the request payload.
 * It uses dot notation on the left side to target nested
 * request properties (compatible with `lodash.filter`).
 *
 * Traits with no filter defined will accept all requests.
 *
 * For credits and debits trait, only the "Prepare" phase is
 * filtered. Meaning if the bridge already received a "Prepare"
 * request, other phases of the same intent will still be delivered.
 * @example
 * bridge.traits = [
 *  'debits', // No filters
 *  {
 *    method: 'credits',
 *    filter: {
 *      'intent.data.schema': 'transfer'
 *    }
 *  }
 * ]
 */
export type BridgeTraitFilter = LedgerFilter | Record<string, Partial<OperatorShape>>;
