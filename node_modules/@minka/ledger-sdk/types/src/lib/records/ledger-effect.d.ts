import { LedgerAccess } from '../common/ledger-access';
import { LedgerCustom } from '../common/ledger-custom';
import { LedgerBaseData } from '../common/ledger-data';
import { LedgerFilter } from '../common/ledger-filter';
import { LedgerHandle } from '../common/ledger-handle';
import { EventSignal } from './ledger-event';
/**
 * Effects describe side-effects that can be triggered
 * because of a change in the ledger data. Effects are
 * the main mechanism for adding new functionality to
 * ledgers that is use case specific.
 *
 * Each change in ledger data structures broadcasts a
 * signal that can be used to notify external systems
 * through effects.
 */
export type LedgerEffect = LedgerBaseData & {
    /**
     * A handle that uniquely identifies an effect.
     */
    handle: LedgerHandle;
    /**
     * A signal that is going to trigger an effect. Signals
     * are broadcasted by the ledger core and signal names
     * are predefined.
     * @link {Signal docs}
     */
    signal: EventSignal;
    /**
     * Filters allow for more granular control of conditions
     * that are going to trigger notifications. Filter can be
     * used to select only certain signals based on metadata
     * sent alongside signals.
     */
    filter?: EffectFilter;
    /**
     * Defines how to notify external systems or ledger plugins.
     * Currently only one mechanism is supported:
     *  `webhook`: call an external system through webhooks
     */
    action: EffectAction;
    /**
     * The schema used to validate this effect. This is mandatory
     * if there is at least one schema defined for the record
     * type `effect`.
     */
    schema?: LedgerHandle;
    /**
     * Custom metadata that can be stored alongside an effect
     * definition.
     */
    custom?: LedgerCustom;
    /**
     * Access control rules to define who can control or manage
     * an effect.
     */
    access?: LedgerAccess;
};
/**
 * Filter rules to reject some of the events.
 *
 * Filter targets the `data` part of the ledger event record.
 * It uses dot notation on the left side to target nested
 * event properties (compatible with `lodash.filter`).
 * @example
 * effect.filter = {
 *   'wallet.data.handle': 'bank1'
 * }
 */
export type EffectFilter = LedgerFilter;
/**
 * Action defines how to deliver notification when a matching
 * signal is detected. Currently only webhook is supported but
 * latter we will add more of them as union of specific types.
 */
export type EffectAction = EffectWebhookAction | EffectBridgeAction;
/**
 * Effect action schema. Defines the type of action
 * performed when effect is triggered.
 */
export declare enum EffectActionSchema {
    webhook = "webhook",
    bridge = "bridge"
}
/**
 * All possible effect action schemas.
 */
export declare const EffectActionSchemas: EffectActionSchema[];
/**
 * Webhook effect action. Represents HTTPS call to
 * webhook endpoint with event payload sent in body.
 */
export type EffectWebhookAction = {
    /**
     * Webhook schema
     */
    schema: EffectActionSchema.webhook;
    /**
     * Webhook endpoint
     */
    endpoint: string;
};
/**
 * Bridge effect action. Represents HTTPS call to
 * a bridge stored in ledger. Ledger calls bridge effects endpoint
 * with event payload sent in body and effect handle in path.
 */
export type EffectBridgeAction = {
    /**
     * Bridge schema
     */
    schema: EffectActionSchema.bridge;
    /**
     * Bridge handle
     */
    bridge: LedgerHandle;
};
