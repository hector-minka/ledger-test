import { LedgerRecord } from '../base/ledger-record';
import { ChangeMeta } from '../common/change-meta';
import { LedgerAccess } from '../common/ledger-access';
import { LedgerAddress } from '../common/ledger-address';
import { LedgerCustom } from '../common/ledger-custom';
import { LedgerBaseData } from '../common/ledger-data';
import { LedgerHandle } from '../common/ledger-handle';
import { LedgerMeta, LedgerProofCustom } from '../common/ledger-meta';
import { LedgerReference } from '../common/ledger-reference';
import type { MergeExclusive } from 'type-fest';
/**
 * Intent status represents the phase of intent processing.
 * - pending: initial status, executing preconditions, awaiting
 * for prepare confirmations from all involved bridges
 * - prepared: prepare confirmations from all involved bridges
 * are received
 * - committed: balance changes are committed to database,
 * awaiting for commit confirmations from all involved bridges
 * - completed: commit confirmations from all involved bridges
 * are received
 * - aborted: intent is aborted, it will not be committed
 * to database, awaiting for abort confirmations from all
 * involved bridges
 * - rejected: abort confirmations from all involved
 * bridges are received
 */
export declare enum IntentStatus {
    Pending = "pending",
    Prepared = "prepared",
    Committed = "committed",
    Completed = "completed",
    Failed = "failed",
    Aborted = "aborted",
    Rejected = "rejected"
}
/**
 * Intent change metadata.
 */
export type IntentChangeMeta = MergeExclusive<ChangeMeta<IntentProofCustom>, IntentMeta>;
/**
 * Ledger metadata.
 */
export type IntentMeta = LedgerMeta<IntentProofCustom> & {
    /**
     * Thread is a handle used to link multiple ledger records
     * together when necessary to establish a common context. It
     * is usually used to link intents during routing.
     */
    thread?: LedgerHandle;
    /**
     * Intent status
     */
    status: IntentStatus;
    /**
     * Flag which indicates whether the routing is executed on the intent.
     */
    routed?: boolean;
};
export type IntentRecord = LedgerRecord<LedgerIntent, IntentMeta>;
/**
 * Intents describe all ledger balance movements. Each
 * intent can contain one or more claims. A claim is a
 * statement about an action that user or system wants
 * to record in a ledger.
 *
 * Claims can describe various actions, and number of
 * supported actions is expected to grow over time as
 * new use cases are supported.
 *
 * All claims that are part of an intent are going to
 * be cleared by the ledger atomically. This means that
 * either all or none of the intent claims are going to
 * be accepted by the ledger.
 *
 * Intents must also have a unique handle. This property
 * is used to ensure idempotency of operations in case of
 * timeouts and retries. It can also be useful as means
 * of efficiently retrieving past intents. Handle can be
 * generated randomly or it can be a user supplied value,
 * but it has to be unique for each intent.
 *
 * Intents supports custom data in the same way as all
 * other ledger records. Custom data can be used to record
 * additional metadata about an operation. For example, you
 * can record an invoice id that is being payed, a payment
 * description, type of payment, location, etc.
 */
export type LedgerIntent = LedgerBaseData & {
    /**
     * Intent handle or identifier, handle is used to
     * uniquely identify each intent. It can be used to
     * later retrieve it and to prevent duplicate intents.
     */
    handle: LedgerHandle;
    /**
     * An array of claims that should be fulfilled when this
     * intent is cleared by the ledger. Either all claims are
     * going to be fulfilled or none of them is going to be
     * fulfilled. Claims are fulfilled in the order they are
     * specified.
     */
    claims: LedgerClaim[];
    /**
     * The schema used to validate this intent. This is mandatory
     * if there is at least one schema defined for the record
     * type `intent`.
     */
    schema?: LedgerHandle;
    /**
     * Custom metadata, this object can hold any additional data
     * that could be useful to end users or ledger plugins to work
     * with intents. For example, you can record an invoice id that
     * is being payed, a payment description, type of payment,
     * location, etc.
     */
    custom?: LedgerCustom;
    /**
     * Determines access controls. This field can be used to
     * limit read access, control continuation, etc.
     */
    access?: LedgerAccess;
    /**
     * The origin of the intent represents the intent that
     * caused this intent to be generated. It is used, among
     * other things, to determine the thread that this intent
     * belongs to.
     */
    origin?: LedgerHandle;
    /**
     * Intent config object that contains configuration
     * options about intent processing.
     */
    config?: IntentConfig;
};
/**
 * Claims describe various actions that can be fulfilled
 * as part of intents. Currently supported actions are
 * symbol issuing and transfer of balances.
 */
export type LedgerClaim = IssueClaim | TransferClaim | DestroyClaim | LimitClaim;
/**
 * Describes the type of the action that will be performed.
 */
export declare enum ClaimAction {
    Issue = "issue",
    Transfer = "transfer",
    Destroy = "destroy",
    Limit = "limit"
}
/**
 * All possible claim actions.
 */
export declare const ClaimActions: ClaimAction[];
/**
 * Represents an operation of issuing new amount of
 * a symbol. When this claim is fulfilled, the specified
 * target wallet will receive a new balance of the symbol
 * that is being issued.
 */
export type IssueClaim = {
    /**
     * Represents the name of the action that should be
     * fulfilled.
     */
    action: ClaimAction.Issue;
    /**
     * Address that should receive the issued amount.
     */
    target: LedgerReference<LedgerAddress>;
    /**
     * The handle of a symbol that is being issued.
     */
    symbol: LedgerReference;
    /**
     * The amount that is being issued.
     */
    amount: number;
    /**
     * Custom data that can be attached to the
     * claim.
     */
    custom?: LedgerCustom;
};
/**
 * Represents a balance movement within a ledger.
 * Balances are moved from a source wallet to a target
 * wallet. After this claim is fulfilled, the target
 * wallet will receive a new balance of the symbol that
 * is being transferred, while the balance of the source
 * wallet will be decreased by the same amount. This
 * claim will fail if the source balance is insufficient.
 */
export type TransferClaim = {
    /**
     * Represents the name of the action that should be
     * fulfilled.
     */
    action: ClaimAction.Transfer;
    /**
     * Address that is sending the specified amount.
     */
    source: LedgerReference<LedgerAddress>;
    /**
     * Address that should receive the specified amount.
     */
    target: LedgerReference<LedgerAddress>;
    /**
     * The handle of a symbol that is being transferred.
     */
    symbol: LedgerReference;
    /**
     * The amount that is being transferred.
     */
    amount: number;
    /**
     * Custom data that can be attached to the
     * claim.
     */
    custom?: LedgerCustom;
};
/**
 * Represents an operation of destroying an amount of
 * a symbol. When this claim is fulfilled, the specified
 * amount will be removed from the source wallet
 */
export type DestroyClaim = {
    /**
     * Represents the name of the action that should be
     * fulfilled.
     */
    action: ClaimAction.Destroy;
    /**
     * Address that should clear away the destroyed amount.
     */
    source: LedgerReference<LedgerAddress>;
    /**
     * The handle of a symbol that is being destroyed.
     */
    symbol: LedgerReference;
    /**
     * The amount that is being destroyed.
     */
    amount: number;
    /**
     * Custom data that can be attached to the
     * claim.
     */
    custom?: LedgerCustom;
};
/**
 * Represents an operation of limitting an amount or
 * statistic of a symbol in certain wallet. The limit will
 * take effect when this claim is cleared by the ledger.
 */
export type LimitClaim = {
    /**
     * Represents the name of the action that should be
     * fulfilled.
     */
    action: ClaimAction.Limit;
    /**
     * Address to apply the limit to.
     */
    wallet: LedgerReference<LedgerAddress>;
    /**
     * The handle of a symbol that is being limitted.
     */
    symbol: LedgerReference;
    /**
     * The amount that is being limitted.
     */
    amount: number;
    /**
     * The metric to be limitted.
     */
    metric: LimitClaimMetric;
    /**
     * Custom data that can be attached to the
     * claim.
     */
    custom?: LedgerCustom;
};
/**
 * Records are usually signed to record results of operations
 * performed by external systems which are identified by key
 * pairs. Status property can be used to attach additional
 * information about a status of those operations along with the
 * signature.
 */
export type IntentProofStatus = IntentStatus | 'pending' | 'prepared' | 'requested' | 'failed' | 'committed' | 'completed' | 'aborted' | 'rejected' | 'created' | 'error' | 'expired';
/**
 * Additional information that can be attached to a signature in
 * order to explicitly define the reason for adding a signature
 * to an intent.
 */
export type IntentProofCustom = LedgerProofCustom<IntentProofStatus> & {
    /**
     * Handle is a unique identifier of an action delivered to an external
     * system for which the signature is added as a response. It is used to
     * correlate the action with the signature sent by an external system.
     *
     * Also used for idempotency so an external system can discard an action
     * if it already received the action with same handle before. This
     * condition is possible as edge case with retries mechanism.
     */
    handle?: LedgerHandle;
    /**
     * Core ID is an unique external reference in a signature. This property
     * is used to record a unique identifier of an operation performed by an
     * external system in order to fullfil an action call.
     *
     * This is property should contain a transaction id in an external system.
     */
    coreId?: string;
};
/**
 * All the metrics that can be limited.
 *
 * - MinBalance -> The minimum balance of a wallet.
 * - MaxBalance -> The maximum balance of a wallet.
 * - DailyCount -> The maximum number of transactions per day.
 * - DailyAmount -> The maximum amount of transactions per day.
 */
export declare enum LimitClaimMetric {
    MinBalance = "minBalance",
    MaxBalance = "maxBalance",
    DailyCount = "dailyCount",
    DailyAmount = "dailyAmount"
}
export declare const LimitClaimMetrics: LimitClaimMetric[];
/**
 * Defines how the intent should be committed.
 * - 'auto' -> The intent is automatically committed after
 *             receiving all required signatures to prepare
 * - 'manual' -> The intent is suspended and will await
 *             for a trigger to commit or abort.
 */
/**
 * Action corresponding to the signature.
 */
export declare enum IntentSignatureAction {
    Commit = "commit",
    Abort = "abort"
}
export declare const IntentSignatureActions: IntentSignatureAction[];
export declare enum IntentCommitMode {
    Auto = "auto",
    Manual = "manual"
}
export declare const IntentCommitModes: IntentCommitMode[];
/**
 * Intent config object that contains configuration
 * options about intent processing.
 */
export type IntentConfig = {
    /**
     * Enable auto commit for this intent. If it's 'auto',
     * the intent will be automatically committed when prepared
     * by the participants.
     */
    commit?: IntentCommitMode;
};
