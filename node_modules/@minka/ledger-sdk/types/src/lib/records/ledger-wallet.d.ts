import { LedgerRecord } from '../base/ledger-record';
import { LedgerAccess } from '../common/ledger-access';
import { LedgerAddress } from '../common/ledger-address';
import { LedgerCustom } from '../common/ledger-custom';
import { LedgerBaseData } from '../common/ledger-data';
import { LedgerFilter } from '../common/ledger-filter';
import { LedgerHandle } from '../common/ledger-handle';
export type WalletRouteFilter = LedgerFilter;
export declare enum WalletRouteAction {
    Forward = "forward",
    Accept = "accept",
    Debit = "debit",
    Credit = "credit"
}
export declare const WalletRouteActions: WalletRouteAction[];
export type WalletRoute = WalletInRoute | WalletOutRoute;
export type WalletInRoute = {
    action: WalletRouteAction.Debit;
    filter?: WalletRouteFilter;
    target?: LedgerAddress;
};
export type WalletOutRoute = {
    action: Exclude<WalletRouteAction, WalletRouteAction.Debit>;
    filter?: WalletRouteFilter;
    target?: LedgerAddress;
};
/**
 * Wallets are ledger records that hold balances. Each
 * wallet has a unique handle that identifies it. This
 * handle is used in intents, balance queries, and any
 * other operations involving a wallet.
 *
 * Handle is defined by the user, so it is useful to
 * use something that is user friendly and easy to
 * remember. Handles can be phone numbers, emails,
 * bank account numbers, usernames, etc. Format and
 * types of handles mostly depends on the use case
 * that is being built on top of a ledger.
 *
 * Wallets are used to represent anything that can
 * hold a balance. For example, bank accounts, loyalty
 * point accounts, subscriptions, bills, loans, etc.
 * All of those use cases can be modeled by mapping
 * them to wallets.
 */
export type LedgerWallet = LedgerBaseData & {
    /**
     * Wallet handle or identifier, handle is used to
     * identify a wallet in each intent, balance query,
     * and other operations involving a wallet.
     */
    handle: LedgerAddress;
    /**
     * Reference to a bridge. Used when balance movements to
     * and from the wallet needs to be processed on external
     * ledger. If wallet has a bridge reference than this bridge
     * will be used as participant in distributed commit of the
     * intent which spends or gives balance to a wallet. Multiple
     * bridges can participate in distributed commit of the
     * single intent.
     */
    bridge?: LedgerHandle;
    /**
     * The schema used to validate this wallet. This is mandatory
     * if there is at least one schema defined for the record
     * type `wallet`.
     */
    schema?: LedgerHandle;
    /**
     * Custom metadata, this object can hold any additional
     * data that could be useful to end users or ledger
     * plugins to work with wallets. For example this can be
     * a type of a wallet, bank account details, interest
     * rates, etc.
     */
    custom?: LedgerCustom;
    /**
     * Determines access controls. This field can be used to
     * limit updates, payment initiation, etc.
     */
    access?: LedgerAccess;
    /**
     * Routes allow setting up automatic rules for funds
     * management on wallets. By registering a route, user is
     * delegating authority to ledger to perform the described
     * operation under defined permissions in the name of that user.
     */
    routes?: WalletRoute[];
};
export type WalletRecord = LedgerRecord<LedgerWallet>;
